- [Parte 2: Difese](#parte-2-difese)
  - [Sicurezza di Rete](#sicurezza-di-rete)
    - [Segmentazione e Segregazione](#segmentazione-e-segregazione)
    - [Attacchi MitM in LAN](#attacchi-mitm-in-lan)
      - [ARP Spoofing](#arp-spoofing)
      - [Port Stealing](#port-stealing)
      - [DHCP Poisoning](#dhcp-poisoning)
      - [Soluzione: Virtual LAN (VLAN)](#soluzione-virtual-lan-vlan)
      - [NATting e PATting](#natting-e-patting)
        - [Pro e Contro del Natting](#pro-e-contro-del-natting)
  - [Firewall](#firewall)
    - [Politiche per la Sicurezza di Rete](#politiche-per-la-sicurezza-di-rete)
    - [Funzionalità dei firewall](#funzionalità-dei-firewall)
      - [Packet Filter](#packet-filter)
      - [Application Gateway (Proxy Firewall)](#application-gateway-proxy-firewall)
      - [Next Generation Firewall (NGFW)](#next-generation-firewall-ngfw)
    - [IPtables](#iptables)
      - [Netfilter](#netfilter)
      - [Packet Marking](#packet-marking)
      - [Configurazione IPtables](#configurazione-iptables)
    - [Configurazioni possibili](#configurazioni-possibili)
      - [Screening Router](#screening-router)
      - [Dual-Homed Gateway/Filter](#dual-homed-gatewayfilter)
      - [Screened Host/Gateway](#screened-hostgateway)
      - [De-Militarized Zone (DMZ)](#de-militarized-zone-dmz)
        - [Tipiche Politiche per DMZ](#tipiche-politiche-per-dmz)
      - [Two Legged Network](#two-legged-network)
      - [Screened subnet](#screened-subnet)
      - [Single host vs Dual host](#single-host-vs-dual-host)
  - [Crittografia Hashing e Steganografia - Introduzione](#crittografia-hashing-e-steganografia---introduzione)
    - [Garanzie desiderate](#garanzie-desiderate)
    - [Crittologia](#crittologia)
    - [Crittografia](#crittografia)
      - [Sicurezza Incondizionata e Computazionale](#sicurezza-incondizionata-e-computazionale)
      - [Crittografia "Classica" e "Moderna"](#crittografia-classica-e-moderna)
    - [Crittoanalisi](#crittoanalisi)
    - [Steganografia](#steganografia)
      - [Steganografia Moderna](#steganografia-moderna)
  - [Crittografia Classica](#crittografia-classica)
    - [Cifrari "Classici"](#cifrari-classici)
      - [Algoritmi Simmetrici](#algoritmi-simmetrici)
      - [Codifica e Cifratura](#codifica-e-cifratura)
      - [Cifrari per Sostituzione](#cifrari-per-sostituzione)
        - [Cifrari Monoalfabetici](#cifrari-monoalfabetici)
          - [Basati su Alfabeto Sostitutivo](#basati-su-alfabeto-sostitutivo)
        - [Crittoanalisi](#crittoanalisi-1)
          - [Crittoanalisi Statistica](#crittoanalisi-statistica)
        - [Algoritmi Polialfabetici](#algoritmi-polialfabetici)
          - [One Time Pad](#one-time-pad)
    - [Cifrari per Trasposizione](#cifrari-per-trasposizione)
    - [Cifrari Prodotto](#cifrari-prodotto)
      - [Cifrario ADFGVX](#cifrario-adfgvx)
  - [Crittografia Simmetrica e Hashing](#crittografia-simmetrica-e-hashing)
    - [Macchine cifranti](#macchine-cifranti)
    - [Crittografia Moderna](#crittografia-moderna)
    - [Cifrari a Blocchi](#cifrari-a-blocchi)
      - [Problemi del Cifrario Ideale](#problemi-del-cifrario-ideale)
      - [Cifrari a Blocchi - Feistel](#cifrari-a-blocchi---feistel)
        - [Cifrare con Feistel](#cifrare-con-feistel)
          - [Feistel - Lucifer (Procedimento)](#feistel---lucifer-procedimento)
        - [Decifrare con Feistel](#decifrare-con-feistel)
      - [Cifrari a Blocchi - DES (Data Encryption Standard)](#cifrari-a-blocchi---des-data-encryption-standard)
        - [2DES](#2des)
          - [Meet-in-the-Middle](#meet-in-the-middle)
        - [3DES](#3des)
      - [Cifrari a Blocchi - AES (Advanced Encryption Standard)](#cifrari-a-blocchi---aes-advanced-encryption-standard)
    - [Cifrari a Flusso](#cifrari-a-flusso)
      - [Cifrari a flusso - RC4](#cifrari-a-flusso---rc4)
        - [Funzionamento](#funzionamento)
    - [Integrità](#integrità)
      - [Funzioni di hash](#funzioni-di-hash)
        - [Message Digest (MD)](#message-digest-md)
        - [Secure Hash Algorithm (SHA)](#secure-hash-algorithm-sha)
        - [Whirlpool](#whirlpool)
      - [Funzioni MAC](#funzioni-mac)
        - [HMAC](#hmac)
  - [Crittografia Asimmetrica](#crittografia-asimmetrica)
    - [Problemi della crittografia simmetrica](#problemi-della-crittografia-simmetrica)
      - [Possibili Soluzioni](#possibili-soluzioni)
      - [Crittografia Asimmetrica - RSA](#crittografia-asimmetrica---rsa)
        - [Fattorizzazione](#fattorizzazione)
        - [Aritmetica Modulare](#aritmetica-modulare)
        - [Funzionamento RSA](#funzionamento-rsa)
        - [Applicazioni](#applicazioni)
      - [Scambio di chiavi Diffie-Hellman](#scambio-di-chiavi-diffie-hellman)
  - [Firma Digitale e Certification Authority](#firma-digitale-e-certification-authority)
    - [Garanzie sul messaggio](#garanzie-sul-messaggio)
    - [Terze parti fidate](#terze-parti-fidate)
      - [CA Certification Authority](#ca-certification-authority)
        - [Rilascio CA (Certificato Digitale X.509)](#rilascio-ca-certificato-digitale-x509)
        - [Verifica CA](#verifica-ca)
          - [Certificazione "paritetica"](#certificazione-paritetica)
          - [Browser e CA](#browser-e-ca)
          - [Certificate Chain](#certificate-chain)
        - [Revoca CA](#revoca-ca)
          - [Hardening Public PKI](#hardening-public-pki)
          - [CA Private](#ca-private)
  - [Protocolli Sicuri](#protocolli-sicuri)
    - [IPsec](#ipsec)
      - [Security Association](#security-association)
        - [Protocollo AH](#protocollo-ah)
        - [Protocollo ESP](#protocollo-esp)
      - [Scambio delle Chiavi](#scambio-delle-chiavi)
      - [IPsec - Sintesi](#ipsec---sintesi)
    - [SSL](#ssl)
  - [Servizi Applicativi Sicuri](#servizi-applicativi-sicuri)
    - [Web - https](#web---https)
    - [Mail - smtp](#mail---smtp)
      - [S/MIME](#smime)
      - [PGP](#pgp)
        - [Funzionamento](#funzionamento-1)
        - [La storia](#la-storia)
      - [GPG](#gpg)
        - [Utilizzo](#utilizzo)
        - [Web of Trust](#web-of-trust)
          - [Creazione di un Certificato](#creazione-di-un-certificato)
          - [Scadenza di un Certificato](#scadenza-di-un-certificato)
    - [Posta Elettronica Certificata - PEC](#posta-elettronica-certificata---pec)
    - [Secure Shell - SSH](#secure-shell---ssh)
  - [Autenticazione e Autorizzazione](#autenticazione-e-autorizzazione)
    - [Autenticazione](#autenticazione)
      - [One-Time Password](#one-time-password)
        - [HOTP](#hotp)
          - [Esempio](#esempio)
        - [TOTP](#totp)
    - [Autorizzazione](#autorizzazione)
      - [Autenticazione e Autorizzazione Centralizzata - LDAP](#autenticazione-e-autorizzazione-centralizzata---ldap)
      - [Kerberos](#kerberos)
      - [Microsoft Active Directory](#microsoft-active-directory)
    - [Single Sign On](#single-sign-on)
      - [Benefici di SSO](#benefici-di-sso)
      - [Problemi di SSO](#problemi-di-sso)
    - [Zero Trust Architecture](#zero-trust-architecture)
      - [BeyondCorp di Google](#beyondcorp-di-google)
        - [Identificazione dei Dispositivi](#identificazione-dei-dispositivi)
        - [Funzionamento](#funzionamento-2)
        - [Controlli per l'accesso](#controlli-per-laccesso)
        - [Identificazione](#identificazione)
        - [Livello di Fiducia](#livello-di-fiducia)
        - [Problemi di Gestione](#problemi-di-gestione)
  - [Security Monitoring e Intrusion Detection](#security-monitoring-e-intrusion-detection)
    - [Monitoraggio Continuo](#monitoraggio-continuo)
      - [Eventi di Rete](#eventi-di-rete)
        - [Full Packet Capture](#full-packet-capture)
        - [Network Metadata](#network-metadata)
        - [Netflow](#netflow)
        - [Confronto (in *ambito telefonico*)](#confronto-in-ambito-telefonico)
      - [Eventi di Sistema](#eventi-di-sistema)
      - [Threat Intelligence](#threat-intelligence)
    - [Intrusion Detection Systems](#intrusion-detection-systems)
      - [Funzionalità base](#funzionalità-base)
      - [Valutazione Algoritmica](#valutazione-algoritmica)
      - [Valutazione Sistemistica](#valutazione-sistemistica)
      - [Metodi di Rilevamento](#metodi-di-rilevamento)
      - [Localizzazione della Funzione di Analisi](#localizzazione-della-funzione-di-analisi)
  - [VPN - Virtual Private Network](#vpn---virtual-private-network)

# Parte 2: Difese

## Sicurezza di Rete

Più si sale nello stack TCP/IP e più le ***funzioni di sicurezza*** possono essere *specifiche* ed *indipendenti* dalle reti sottostanti, soluzioni computazionalmente più onerose e quindi *difficili* da realizzare in reti ad alto traffico. Più si resta in basso nello stack e più sarà possibile "espellere" in fretta gli intrusi, ma le informazioni su cui basare le decisioni saranno più scarse (indirizzo MAC o IP, nessuna informazione su utenti, comandi e applicazioni). È opportuno introdurre ***meccanismi di sicurezza a tutti i livelli*** in base alle specifiche esigenze e ai vincoli (budget).

### Segmentazione e Segregazione

Si tratta dei *due principali principi di sicurezza*:

**Segmentazione**: *partizionare le risorse* aziendali logistiche e fisiche. Suddividere le *reti in sottoreti* (reti per personali con ruoli differenti), evitare share di rete aperti.

**Segregazione**: applicare controllo degli accessi, definire politiche per accessi cross-segment, applicare politiche mediante opportune tecnologie

Per segmentare e segregare il traffico si utilizzano tecniche come Virtual LAN (VLAN), Network Address Translation (NAT) e Port Address Translation (PAT), De-Militarized Zone (DMZ) e Firewall.

### Attacchi MitM in LAN

In una LAN tradizionale gli host sono aggregati "fisicamente" mediante dispositivi di rete quali hub, switch e router:

- Hub: non differenziano il dominio di collisione né il dominio di broadcast
- Switch: differenziano il dominio di collisione ma non il dominio di broadcast
- Router: differenziano sia il dominio di collisione sia il dominio di broadcast

Un attacco MitM si verifica quando un attaccante (sulla stessa rete della vittima) è in grado di ritrasmettere (e alterare) la comunicazione tra due parti senza che queste se ne accorgano.

#### ARP Spoofing

Viene ***ingannato l'OS della vittima*** inviando delle *risposte ARP*, che non devono essere necessariamente correlate a delle richieste. L'OS della vittima associa erroneamente un indirizzo IP della LAN al MAC Address dell'attaccante.

```bash
ettercap -T -M arp /192.168.1.1//
```

**Soluzione**: Configurare le *tabelle ARP sull'OS di ciascun host in maniera statica*.

#### Port Stealing

In questo caso viene ***ingannato lo switch***, facendogli *apprendere informazioni errate*. Per ingannare lo switch si utilizza il seguente comando: 

```bash
ettercap -T -M port /192.168.1.1//
```

Con questo comando ettercap genera un numero di frame ethernet ripetuti il cui *MAC Address sorgente* è *quello dei suoi obiettivi*. Lo switch in questo modo è convinto che tutti gli host obiettivo siano collegati a un'unica porta di rete. Questo tipo di attacco è fortemente ***dipendente dalla quantità di traffico*** presente nella rete: se un host manda tanto traffico è più difficile ingannare uno switch che quell'host ha cambiato porta alla quale è connesso. Si confonde lo switch affinché inoltri all'attaccante i pacchetti diretti alla vittima: il problema è che *l'attaccante non ha modo di far si che i pacchetti raggiungano poi la vittima*, perché avendo rubato la porta della vittima se provasse a mandarle il pacchetto sniffato questo verrebbe rimandato indietro all'attaccante stesso. 

**Soluzione**: Creare *associazioni statiche MAC/porta sullo switch*.

#### DHCP Poisoning

Questo attacco torna utile nel caso in cui sia la tabella ARP degli host che le porte dello switch siano configurate staticamente. Quando un host si connette alla rete manda una DHCP\_REQUEST a broadcast e attende una DHCP\_RESPONSE dal *DHCP Server* contenente tutti i parametri di configurazione della rete (gateway, netmask, IP, DNS, ecc...). Utilizzando ettercap: 

```bash
ettercap -T -M dhcp:192.168.1.5-10/255.255.255.0/192.168.1.3
```

Con questo comando la macchina ***finge di essere un server DHCP***, quindi si mette in ascolto in attesa di DHCP\_REQUEST, quando questa arriva, chi risponde per primo tra attaccante e router vince. 

**Soluzione**: *Configurare staticamente le interfacce di rete*. La soluzione agli attacchi MitM LAN sta nell'evitare configurazioni automatiche, preferendo quelle statiche.

#### Soluzione: Virtual LAN (VLAN)

Non nasce come soluzione per la sicurezza delle rete: è un approccio di **Livello 2** (*data-link*). Permette di ***separare l'architettura fisica della rete da quella logica***. Una VLAN permette di avere una *maggiore flessibilità di gestione della rete*: per quegli host che non hanno bisogno di condividere informazioni, oppure per dipendenti che si spostano ogni anno.

Con la creazione di una VLAN si ha la ***creazione di un dominio broadcast***: gli host nella stessa VLAN possono comunicare direttamente, quelli in VLAN differenti comunicano tramite un dispositivo di rete (router). Così facendo è possibile proteggersi da tutti e 3 gli attacchi di MitM (a meno che Eve non sia connesso alla stessa VLAN). Quando un frame viene inviato in broadcast agli host di una VLAN alla quale sono associate delle porte su due switch separati, il ***frame contiene un identificatore della VLAN*** concordato dagli switch. Il frame parte e arriva a destinazione come *frame ethernet normale*, sono gli *switch che aggiungono l'identificatore* quando se lo *trasferiscono*. Il collegamento tra due switch che condividono una VLAN sul quale passa questo frame si chiama ***link di trunk***.

Gli host possono essere aggregati in VLAN mediante soluzioni software basate su numero di porta, indirizzo MAC, indirizzo IP, tipo di protocollo. È possibile realizzare VLAN mediante configurazione statica e dinamica.

#### NATting e PATting

Approccio di **Livello 3** (*Rete, IP*). Per molte organizzazioni è importante avere reti semi-private con tre categorie di host:

- Nessun accesso da/a host fuori dall'organizzazione
- Accesso parziale (verso l'*esterno*)
- Accesso completo (interno ed esterno, tipico di *server web*)

Gli indirizzi riservati alle reti locali sono di classe A, B e C. Per permettere agli *host privati* (non visibili da Internet) di *comunicare con host pubblici*, sono possibili due approcci:

1. **Proxy Server** (Livello *Applicativo*)
2. **Network Address Translation** **(NAT)** (Livello di *Rete*)

Un *NAT Router* aumenta la sicurezza della rete evitando di rendere visibili dall'esterno i computer appartenenti a un dominio interno, inoltre si occupa di ***mappare gli indirizzi IP locali in indirizzi IP globali***. Il problema per il router si verifica quando *riceve i pacchetti* e deve ***ricordare a quale indirizzo privato corrispondono***: per farlo utilizza il **Port Address Translation (PAT)**.

Quando un client apre una nuova connessione utilizza un numero di porta $>1024$ che in quel momento non è utilizzato dal SO (meglio se la porta non è prevedibile). Il router a questo punto *non si limita a cambiare l'indirizzo IP* (NATting), ma *anche il numero di porta* (PATting) con uno di quelli che attualmente non sta utilizzando. Il *NAT Router* ***salva il binding*** in una sua ***tabella di stato***. Il binding può essere di due tipi:

- **binding statico**: la tabella viene configurata manualmente (utile nel caso si ha un *web server* che deve essere raggiungibile dall'esterno)
- **binding dinamico**: la tabella viene calcolata dinamicamente dal router e cambia nel tempo a seconda del traffico

##### Pro e Contro del Natting

**Svantaggi**

- Distrugge la ***semantica della comunicazione internet*** *stateless* e *end-to end* in quanto gli *host interni non possono essere raggiunti direttamente dall'esterno* e il *NAT router mantiene uno "stato" sulla connessione* (può causare problemi con protocolli come *FTP* dove c'è una *connessione di controllo* *Client&rarr;Server* e una di *trasferimento dati peer-to-peer* *Server&rarr;Client*).

**Vantaggi**

- Per *raggiungere gli host interni occorre passare attraverso un elemento di controllo centralizzato*: **ottima soluzione per la sicurezza**.
- Soluzione *economica*, relativamente facile e veloce
- Consente massima flessibilità nella gestione interna degli indirizzi (aggiunte, eliminazioni, modifiche) senza necessità di richiedere alcun permesso al proprio ISP né di comunicare ad altri eventuali modifiche.

## Firewall

Il Firewall nasce con lo ***scopo di migliorare la sicurezza di una rete***: è un dispositivo che si interpone tra due reti diverse (con *politiche di sicurezza diverse*) per *controllare* e *limitare il traffico*. Deve obbedire a *3 principi*: 

1. Deve essere l'**unico punto di contatto** tra la rete esterna e la rete interna. 
2. Solo il **traffico autorizzato** o non vietato deve riuscire ad attraversare il firewall. 
3. Il Firewall deve essere un **sistema sicuro** che bisogna mantenere *sotto controllo*: solo qualcuno di autorizzato può collegarsi all'*interfaccia di gestione*.

### Politiche per la Sicurezza di Rete

Le politiche di sicurezza si definiscono mediante **Access Control List** (***ACL***):

- Quali servizi sono consentiti
- Come e da chi devono essere utilizzati
- Eventuali eccezioni alle regole precedenti

Il *cosa fanno le ACL* si decide in base alla ***politica di default*** (modalità di funzionamento) adottata dal firewall:

1. **negazione implicita** (*più sicura*): non passa niente tranne ciò che è stato espressamente autorizzato. 
2. **accesso implicito** (*maggiore usabilità)*: passa tutto ciò che non è stato espressamente vietato. Fino a quando non vengono specificate delle regole il *firewall si comporta da router*.

I **controlli effettuati dal firewall** possono essere eseguiti sia a livello ***user space*** che a livello di ***kernel***. La seconda è preferibile per i controlli di basso livello perché più sicura ed efficiente. Nel caso in cui i controlli siano sofisticati (ad esempio a livello applicativo) allora si preferisce lo *user space* per non introdurre troppo over-head a livello di kernel. Un firewall può essere **hw** (appliance ad-hoc) o **sw** (in esecuzione direttamente sul client). I firewall possono essere applicati sia in ambito *aziendale* che in ambito *personale*.

### Funzionalità dei firewall

Si possono identificare due tipologie principali di firewall sulla base delle funzionalità offerte: **packet filter** e **application gateway**.

#### Packet Filter

Agisce a livello 3 e livello 4 dello stack TCP/IP, ma anche a livello 2 (MAC Address e interfaccia di uscita). I packet filter ***bloccano o lasciano passare il traffico*** che attraversa il firewall definendo i *protocolli*, gli *indirizzi IP* e le *porte* che si possono o non possono utilizzare. Spesso viene *impostato sul router stesso* (router firewall) per permettere l'instradamento dei pacchetti accettati all'interno della rete. Quando un pacchetto arriva al packet filter, il firewall estrae alcune informazioni dall'header e, in base alle regole definite, o lo inoltra o lo scarta. Il filtraggio dei pacchetti può avvenire in due modi:

1. **Static Packet Filtering**: considera i singoli pacchetti come entità individuali, non correlate tra loro. I soli input sono rappresentati dal *pacchetto ricevuto* e dalla *configurazione*. Ogni *regola* è composta da due parti: *espressione di confronto* e l'*azione da eseguire*. Le azioni sono semplici: ACCETTA, RIFIUTA, IGNORA, LOG. I **vantaggi** di questo metodo sono: *basso costo computazionale* e economico, non richiede il mantenimento di informazioni di stato, *semplicità* di implementazione e gestione e ottima scalabilità. Gli **svantaggi** sono che non è in grado di riconoscere pacchetti *appartenenti* (ESTABLISHED) o *correlati* (RELATED) ad una connessione già aperta: occorre aprire numerosi "buchi" più larghi del necessario nel firewall per garantire una comunicazione bidirezionale valida per tutti i protocolli. Risulta vulnerabile a tecniche elementari di firewalking (ottenere informazioni sugli host della rete protetta mediante l'invio di pacchetti ad-hoc)
2. **Stateful Packet Filtering** (o Inspection): capace di esaminare i gruppi di pacchetti correlati tra loro (es. pacchetti appartenenti alla stessa connessione). Vengono mantenute delle *informazioni di stato* che *dipendono dal traffico precedente*. **Risolve** i problemi del filtraggio statico, la dinamicità consiste nella **capacità di distinguere le connessioni già aperte da quelle nuove**, mantenere *tabelle di stato* con le *informazioni relative alle connessioni attive*. Ogni volta che ***si apre una nuova connessione*** il ***firewall crea delle nuove regole specifiche*** (e *temporanee*) valide per la connessione. Quando viene inviato un pacchetto appartenente a una connessione chiusa questo viene scartato. **Vantaggi**: riconosce pacchetti appartenenti ad una connessione già aperta (ESTABLISHED), le regole temporanee sono attive solo per il tempo strettamente necessario e infine non è necessario aprire "buchi" permanenti (più resistente al firewalking). **Svantaggi**: Un firewall di questo tipo può essere vulnerabile ad attacchi DoS: il *numero di connessioni che può tenere aperte* sono una *risorsa logica*. Per questo motivo *richiede maggiori quantità di memoria* per mantenere informazioni relative alle connessioni e *maggiore capacità computazionale*. In un contesto di *paralizzazione* (utilizzo di 2 o più firewall) serve un *sistema di bilanciamento del carico* che tenga conto della coppia IP sorgente-destinazione. Inoltre, non è in grado di riconoscere pacchetti (appartenenti a una seconda connessione) correlati ad una (prima) connessione già aperta (RELATED), ciò rappresenta un *limite per quei protocolli che si discostano dal paradigma client-server* (come FTP): questo limite è superabile con l'***ispezione del payload***.

Con l'**Ispezione del Payload** i *pacchetti* non vengono *valutati* solo in base all'header ma anche *sulla base dei dati del payload del pacchetto*, consentendo di interpretare i comandi di livello applicativo contenuti nel payload dei pacchetti di livello 4 (come il *comando* `PORT` nel *protocollo FTP*). **Vantaggi**: riconosce anche pacchetti correlati ad una connessione già aperta (RELATED). **Svantaggi**: ulteriore appesantimento dell'onere computazionale.

#### Application Gateway (Proxy Firewall)

Anche detto proxy firewall, ***opera a livello applicativo***. È composto da un insieme di proxy che esaminano il contenuto dei pacchetti a livello applicazione. Questi firewall si **interpongono** tra client e server, per questo sono anche detti **proxy**. Se un client esterno vuole accedere ad un servizio di una rete interna, i pacchetti devono essere processati dal proxy prima di essere inoltrati al destinatario. Un proxy di questo tipo deve avere un **modulo software** in grado di *riconoscere i protocolli applicativi* (ne riconosce *linguaggio* e *semantica*). **Vantaggi**: a differenza del firewall packet filtering, consente l'analisi completa del protocollo applicativo. **Svantaggi**: *meno performante* (*controlli più complicati*) del packet filtering, *non consente connessioni dirette verso host esterni*. I client interni devono essere appositamente configurati per contattare il proxy firewall, e non il server, infine richiede *supporto esplicito per tutti i protocolli applicativi*. Alcuni problemi sono stati risolti con i **Transparent Application Gateway**: in questa implementazione, il proxy è "trasparente" ai *client*, che *non richiedono configurazioni particolari*, il *traffico viene "automaticamente" dirottato verso il proxy server* mediante tecniche di NATting, rimane il problema che il sistema necessita di molte risorse computazionali e di memoria.

#### Next Generation Firewall (NGFW)

Al giorno d'oggi i firewall "normali" non vengono più venduti. Al loro posto vengono venduti i *Next Generation Firewall* dei prodotti che, oltre a fungere da firewall, hanno diverse funzionalità aggiuntive:

- VPN (IPSec e SSL)
- Intrusion Detection System
- Intrusion Prevention System
- Routing e NAT
- Eventuali servizi di threat intelligence (liste di IP)

Con la vendita di questi prodotti le *grandi aziende produttrici* (es. *Cisco*) hanno sempre *più informazioni sulle attuali minacce informatiche*.

### IPtables

IPtables è un *software applicativo* che consente la realizzazione di regole per filtrare i pacchetti. Lo stack TCP/IP è gestito dal sistema operativo, quindi iptables deve potersi interfacciare con il Kernel Linux. Per farlo iptables sfrutta il **modulo netfilter** che opera fornendo agganci (*hooks*) al sistema operativo utilizzabili per intercettare i pacchetti in transito.

In maniera sintetica i pacchetti possono arrivare dall'esterno (interfaccia di rete) oppure dai processi locali, una volta generati vengono processati da una specifica logica di routing che può decidere di consumare il pacchetto oppure di indirizzarlo a sua volta su una interfaccia di uscita.

#### Netfilter

Netfilter mette a disposizione i seguenti hooks:

1. NF\_IP\_PREROUTING: raggiunto dai pacchetti in ingresso attraverso una interfaccia di rete, e prima di essere sottoposti a routing (hook per DNAT)
1. NF\_IP\_LOCAL\_IN: raggiunto dai pacchetti diretti alla macchina locale
1. NF\_IP\_FORWARD: raggiunto dai pacchetti provenienti da una interfaccia di rete e diretti verso un'altra interfaccia (pacchetti in transito)
1. NF\_IP\_POSTROUTING: raggiunto dai pacchetti già sottoposti a routing e che stanno per uscire dalla macchina locale (hook per SNAT)
1. NF\_IP\_LOCAL\_OUT: attraversato dai pacchetti generati localmente prima di essere sottoposti alla logica di routing

e i seguenti principali valori di ritorno:

- NF\_ACCEPT: accetta il pacchetto
- NF\_DROP: nega l'accesso al pacchetto
- NF\_STOLEN: preleva il pacchetto dal Kernel per manipolazioni in kernel space
- NF\_QUEUE: accorda il pacchetto che viene reso disponibile per una gestione in ambito user space
- NF\_REPEAT: provoca un nuovo transito del pacchetto nel medesimo hook

IPtables prende questo nome proprio perché mette a disposizione delle tabelle alle quali si possono associare un numero arbitrario di *catene*:

1. filter: per operazioni di filtraggio (accettare, rifiutare o ignorare) con le catene:
    - INPUT: pacchetti la cui destinazione è il firewall stesso
    - OUTPUT: pacchetti emessi dal firewall
    - FORWARD: pacchetti che attraversano il firewall
2. nat: per operazioni di traduzione della provenienza e/o destinazione di indirizzi e/o porte. Con le catene:
    - PREROUTING: modifica i pacchetti non appena arrivano
    - POSTROUTING: modifica i pacchetti quando sono pronti ad essere inviati a destinazione
    - OUTPUT: modifica i pacchetti generati dal firewall
3. mangle: riguarda altre modifiche ai pacchetti IP (ad es. ToS (Type of Service), e TTL)
4. raw: permette altre modifiche dei pacchetti prima che raggiungano il sistema di tracciamento della connessione

IPtables può essere usato per impostare delle regole dinamiche (stateful o state aware) utilizzando il modulo **state**. Tale modulo utilizza vari qualificatori utilizzabili all'interno delle espressioni di confronto tra cui:

- NEW: pacchetti necessari per l'apertura di una nuova connessione
- ESTABLISHED: pacchetti appartenenti a connessioni già stabilite in precedenza
- RELATED: pacchetti correlati a connessioni già stabilite (ICMP utili o nuove connessioni nel caso di FTP attivo)

Per le catene di nat, netfilter mette a disposizioni le seguenti actions:

- SNAT: modifica l'indirizzo ip e la porta sorgente di un pacchetto
- MASQUERADE: sostituisce l'indirizzo ip sorgente di un pacchetto con quello dell'interfaccia di rete a cui è destinato (caso particolare di SNAT)
- DNAT: modifica l'indirizzo ip e la porta di destinazione di un pacchetto
- REDIRECT: sostituisce l'indirizzo ip destinazione di un pacchetto con quello dell'host che si occupa del NAT (caso particolare di DNAT)

#### Packet Marking

Gli obiettivi delle regole associate alle catene sono:

- MARK: per impostare il valore dei marcatori di netfilter
- TOS: per impostare il valore del campo TOS
- DSCP: per alterare il valore del campo DSCP (sei bit nel campo TOS)
- ECN: per settare a 0 tutti i bit del campo ECN dei pacchetti TCP
- TCPMSS: per modificare il valore del MSS dei pacchetti TCP SYN

#### Configurazione IPtables

La creazione di un firewall, può richiedere l'utilizzo di merose regole e quindi tanti comandi. Tipicamente i comandi vengono raggruppati all'interno di uno script eseguito all'avvio del firewall.

### Configurazioni possibili

Un'architettura dual host prevede le configurazioni della sicurezza distribuite su più hosts, quelle single host invece hanno un singolo dispositivo che se ne occupa. La **DMZ**, solitamente ospita i server e consiste in una zona *demilitarizzata* ovvero con sicurezza intermedia tra l'ambiente esterno e la rete interna

1. Screening router: Single host
2. Dual-homed gateway/filter: Single host
3. Screened host/gateway: Dual host
4. Two legged network: Single host, supporta DMZ
5. Screened subnet: Dual host, supporta DMZ

#### Screening Router

È un border router con funzionalità firewall su cui ci sono configurate opportune regole per il packet filtering. Questa situazione è spesso presente nelle utenze private a casa. Un border router (router per la connessione ad internet di un'organizzazione) su cui vengono configurate regole per il packet filtering. Tutti i moderni router possono avere almeno funzionalità di packet filter statici (soluzione a basso costo).

Questa soluzione ha i seguenti **problemi**:
- Per mantenere elevate le prestazioni dei dispositivi, spesso hanno solo le funzionalità di packet filter statici
- C'è un **single point of failure**
- Consiste in un'architettura primitiva, ma ancora molto diffusa.

#### Dual-Homed Gateway/Filter
Con dual-homed firewall si intende una soluzione single host che è in grado di eseguire il routing dei pacchetti e di implementare funzionalità di filtraggio OUT-IN e IN-OUT: packet filter e/o proxy firewall. Il firewall ha due schede di rete: una collegata alla rete interna, l'altra alla rete esterna in grado di eseguire il routing dei pacchetti.

Questa soluzione ha i seguenti **problemi**:
- Singolo livello di difesa

#### Screened Host/Gateway

Azione combinata tra **due dispositivi** router e proxy firewall (anche chiamato *bastion host)*.

- Screening Router: Attua packet filtering, *blocca i pacchetti Internet &rarr; LAN* tranne quelli destinati al bastion host e i pacchetti *LAN &rarr; Internet*, tranne quelli provenienti dal bastion host.
- Bastion Host: funziona come *intermediario per i servizi consentiti* (application gateway) per abilitare selettivamente servizi di rete.

Il **bastion host** è la macchina deputata a eseguire il firewall affacciato su internet ed è pertanto una macchina su cui è necessario concentrare notevoli sforzi per migliorarne la sicurezza. A seconda delle architetture può svolgere varie funzioni:

- Effettuare ulteriore filtraggio dei pacchetti
- Fornire servizi al mondo esterno (information server)
- Fornire un proxy (application gateway): caso dello screened-host gateway

Questa soluzione è la più costosa da realizzare e più complessa da gestire rispetto al dual-home gateway dove router e firewall non collaborano. Si ha una **maggiore flessibilità** si può allentare selettivamente il controllo su certi servizi/host, si possono mascherare solo gli host/protocolli che passano dal bastion host.

#### De-Militarized Zone (DMZ)

La DMZ è una parte della rete che *non fa parte né della rete interna, né di quella esterna* (internet). È una *rete intermedia* tra il border router e il bastion host.

- Consente di minimizzare l'esposizione alla rete esterna permettendo l'accesso dall'esterno solo alle macchine della DMZ
- Normalmente nella DMZ si posizionano i server che offrono servizi pubblici di rete (che devono essere raggiungibili dall'esterno): web, mail dns...

##### Tipiche Politiche per DMZ

- LAN &rarr; Internet: tutto permesso (o quasi)
- LAN &rarr; DMZ: permessi solo i protocolli voluti (ad es. 110/TCP)
- Internet &rarr; DMZ: permessi solo i protocolli voluti (es. 25/TCP)
- Internet &rarr; LAN: tutto vietato (permesse solo le risposte per richieste da LAN)
- DMZ &rarr; Internet: permessi solo i protocolli voluti (es. 25/LAN)
- DMZ &rarr; LAN: tutto vietato (permesse solo le risposte per richieste da LAN)

#### Two Legged Network

È la *versione più semplice* che introduce il concetto di DMZ. In questa configurazione (single host) la *DMZ è esposta completamente all'esterno* (**sconsigliato**) sono quindi necessari più indirizzi pubblici.

#### Screened subnet

Ci sono tre componenti che interagiscono:

- Router Esterno
- Bastion Host
- Router Interno

Evoluzione dell'architettura Two Legged Network e Screened Host Gateway: il **router esterno** filtra il traffico tra internet e la DMZ secondo le politiche definite per l'accesso ai server della DMZ consentendo esclusivamente il transito di pacchetti (selettivo) da e verso il bastion host. Il **router interno** protegge sia la rete privata da attacchi provenienti da internet sia i server della DMZ da eventuali attacchi provenienti dall'interno della rete. Se un web server deve essere raggiunto *esclusivamente* dai dispositivi locali la soluzione migliore è sempre quella di tenerlo all'interno della DMZ.

#### Single host vs Dual host

**Vantaggi**:

- Un solo host da configurare e proteggere
- Relativamente poco costosa
- Relativamente facile da configurare, non dovendosi integrare con altri host

**Svantaggi**:

- Single point of failure
- Meno sicure di architetture a più host
- Soluzioni meno flessibili

## Crittografia Hashing e Steganografia - Introduzione

> L'informazione trasmessa via internet è tipicamente accessibile, non cifrata, non autenticata, e pertanto **intrinsecamente insicura** per scelta progettuale di internet.

### Garanzie desiderate

In questi ambiti l'obiettivo è quello di garantire:

- **Riservatezza** dei dati (confidenzialità): anche se intercettata o rubata, l'informazione, non deve essere interpretabile.
- **Integrità** dei dati (memorizzazione e trasmissione): il *messaggio ricevuto è identico a quello inviato* ovvero *l'informazione* memorizzata *non ha subito modifiche*, inserimenti, cancellazioni, riutilizzi.
- **Autenticazione**: certezza della identità.
- **Autorizzazione**: protezione contro utilizzo non autorizzato.
- **Non ripudiabilità**: impossibilità del mittente di negare di aver inviato un messagio.

### Crittologia

La **crittologia** è l'arte e la scienza delle scritture segrete, suddivisibile in tre argomenti:

- **Crittografia** studia come proteggere la riservatezza dei messaggi manipolando l'informazione, *rendendo i dati incomprensibili*.
- **Steganografia** studia come proteggere la riservatezza dei messaggi *nascondendo l'informazione*.
- **Crittoanalisi** studia come violare la riservatezza dei messaggi crittografati o steganografati senza possedere la chiave.

### Crittografia

> Dal greco ***kriptos***, ("cripto", nascosto) + ***grafein***, ("grafein", scrivere)

Arte di progettare **algoritmi** (o cifrari) che, con l'utilizzo di altri parametri (chiave) consente di **cifrare** e **decifrare** un messaggio. Lo **scopo** principale della crittografia è quello di rendere illegibile un testo in chiaro (una sequenza di lettere oppure di numeri) a chi non è stato autorizzato dall'autore, mediante un'operazione nota come **cifratura**. In particolare definiamo i seguenti termini:

- Si dice **testo cifrato** (o **crittogramma**) un testo ottenuto secondo qualche tecnica della crittografia.
- Un **cifrario** indica tutto il *procedimento utilizzato per ottenere il testo cifrato* partendo dal testo in chiaro.
- Con **decifrazione** si intende l'operazione (eseguita dal destinatario) che riporta nella sua forma in chiaro il testo cifrato.

Si definisce **crittosistema** il *sistema di crittografia*, che comprende tutto ciò che serve. È una quintupla **`(M, C, K, E, D)`**:

- **`M`**: testo in chiaro
- **`C`**: testo cifrato
- **`K`**: insieme delle chiavi
- **`E`**: funzioni di crittografia: $M \times K \rightarrow C$
- **`D`**: funzioni di decifratura: $C \times K \rightarrow M$

Nella crittografia **simmetrica** la chiave è **singola** mentre in quella **asimmetrica** si utilizza più di una chiave.

#### Sicurezza Incondizionata e Computazionale

Uno schema di cifratura è detto incondizionatamente sicuro se il testo cifrato generato non contiene abbastanza informazioni per determinare il testo in chiaro, indipendentemente da quanto testo cifrato sia disponibile, con l'eccezione dello schema "one-time pad", nessun algoritmo di cifratura è incondizionatamente sicuro. Quindi, nella pratica *la "sicurezza" si basa su due elementi*:

- Il *costo per crittoanalizzare* il codice *supera il valore dell'informazione* cifrata
- Il *tempo necessario per crittoanalizzare* il codice *supera il tempo* per cui l'informazione contenuta è ritenuta *utile*

Uno schema di cifratura è detto computazionalmente sicuro se rispetta almeno uno dei precedenti due criteri.

#### Crittografia "Classica" e "Moderna"

La crittografia "classica" dura *fino all'avvento delle macchine cifranti*, prima dei computer, si basa sull'utilizzo di una o entrambe le tecniche di **sostituzione** e di **trasposizione**.

La crittografia "moderna" si basa su *tecniche di sostituzione e di trasposizione* ed eventualmente su *algoritmi matematici*: tutti sono implementati al computer. I cifrari moderni si suddividono in:

- Algoritmi simmetrici (a chiave simmetrica o segreta)
- Algoritmi asimmetrici (a chiave asimmetrica o pubblica)

### Crittoanalisi

La **crittoanalisi** è la pratica del rilevare ciò che la crittografia tenta di nascondere. Il crittoanalista, è colui che ha il compito di violare i messaggi cifrati e/o la chiave o almeno scoprire i punti deboli degli algoritmi, in modo da rilevare le comunicazioni segrete anche senza la conoscenza della chiave segreta. Gli **attacchi** di crittoanalisi si basano su fattori come la *natura dell'algoritmo* di cifratura, la *chiave*, qualche *conoscenza del testo* (pattern), *porzione* di corrispondenza del *testo in chiaro* &rarr; testo cifrato. Gli attacchi di **forza bruta** ad esempio, hanno come obiettivo di riuscire a crittoanalizzare il testo cifrato *provando in modo esaustivo tutte le possibili chiavi* finché non si ottiene un testo in chiaro comprensibile. In media, bisogna provare la metà di tutte le chiavi per avere successo.

### Steganografia

> Dal greco ***steganos***, ("coperto", nascosto) + ***grafein***, ("grafein", scrivere)
>
> L'arte di comunicare in modo tale da nascondere l'esistenza stessa della comunicazione. Il fine della steganografia è di nascondere dei messaggi all'interno di altri messaggi innocui.

Arte di proteggere i dati **nascondendoli**, a differenza della crittografia che mira a manipolare i dati rendendoli incomprensibili. La steganografia non trasforma il contenuto (come nel caso della crittografia), ma nasconde l'esistenza stessa del messaggio agli occhi di un qualsiasi osservatore. L'obiettivo della steganografia è quello di **nascondere un messaggio** segreto **dentro un messaggio contenitore** dall'aspetto innocuo e fuorviante. Il senso del messaggio contenitore è generalmente del tutto disgiunto da quello del messaggio segreto, in modo tale che l'avversario non possa neppure rilevarne l'esistenza.

#### Steganografia Moderna

Nella steganografia moderna i "messaggi contenitori" sono diventati **file di copertura**. Tipicamente, i file di copertura moderni sono file multimediali ottenuti direttamente da file digitali o da un processo di conversione analogico-digitale a cui si aggiunge qualche tipo di rumore. Ogni codifica binaria può essere vista come uno strumento di misura più o meno preciso. In questo tipo di file multimediali, è possibile alterare pochi bit senza alterare in modo evidente il contenuto originario. Una tecnica impiegata dai programmi di steganografia consiste nel sostituire i bit meno significativi delle immagini digitalizzate con i bit che costituiscono il file segreto. I bit meno significativi sono infatti assimilabili ai valori meno significativi di una misura, cioè quelli che possono contenere errori di scarso rilievo. Ammesso che da un confronto con l'originale si rilevi una differenza, a occhio (o orecchio) nudo è praticamente impossibile determinare se eventuali perdite di qualità siano dovute a presenza di informazioni nascoste, errore di codifica, scarsa qualità originale dell'immagine (o registrazione sonora). La dimensione delle immagini e video attuali aumenta le possibilità di copertura.

La steganografia può anche essere utilizzata in combinazione con un buon sistema di crittografia: il messaggio da trasmettere viene prima cifrato e poi nascosto nel messaggio contenitore.

## Crittografia Classica

Con l'eccezione dello schema "one-time pad", nessun algoritmo di cifratura è incondizionatamente sicuro. Il livello di segretezza di un testo cifrato dipende da due fattori:
1. Dal cifrario (algoritmo) utilizzato: tenuto segreto nella crittografia classica
2. Dalla complessità della chiave di cifratura che determina il modo in cui un messaggio viene cifrato

### Cifrari "Classici"

I cifrari "classici" utilizzano **algoritmi simmetrici** e possono essere basati su tecniche di **sostituzione**, **trasposizione** o entrambe.

#### Algoritmi Simmetrici

Nei sistemi "simmetrici", viene utilizzata **una sola chiave**, detta **segreta**. La chiave è utilizzata come parametro unidirezionale e invertibile. Poiché si utilizza una funzione invertibile, il destinatario dovrà soltanto elaborare nuovamente il crittogramma, richiamando l'inverso della funzione di cifratura avente come parametro la medesima chiave utilizzata dal mittente. Visto che mittente e destinatario utilizzano la medesima chiave per crittografare e decifrare il messaggio, la crittografia simmetrica *si basa sulla capacità del mittente e del destinatario di mantenere segreta la chiave* di cifratura.

#### Codifica e Cifratura

Si utilizza un **alfabeto sostitutivo** per il messaggio originale, ci si assicura che tutti i destinatari autorizzati a leggere il messaggio abbiano una copia dell'alfabeto sostitutivo o un modo per poterlo ricostruire (es. chiave). Questa forma è stata il metodo alla base della cifratura per migliaia di anni: alfabeto sostitutivo con simboli diversi (codifica) e alfabeto sostitutivo con stessi simboli (cifratura o sostituzione).

#### Cifrari per Sostituzione 

L'obiettivo della **sostituzione** è la confusione per rendere difficile il compito di determinare come un messaggio viene trasformato in un testo cifrato. 

L'esempio più banale sono i *cifrari basati sulla rotazione* come il **Cifrario di Cesare**, che consiste nel ruotare di $n$ posti rispetto all'alfabeto originale (con $n=3$: D &rarr; A). La chiave è data dal *numero di posizioni di shifting* $n$. 

##### Cifrari Monoalfabetici

Sono i *cifrari più semplici*, *basati su **un solo alfabeto di sostituzione*** (es. *Cifrario di Cesare*).

###### Basati su Alfabeto Sostitutivo

Si utilizza un **alfabeto sostitutivo mappato a quello originale** per cifrare il messaggio, così facendo si aumentano drasticamente il numero di combinazioni possibili (`26!` anziché `25` rispetto al Cifrario di Cesare). La *chiave* è data dall'*intero alfabeto sostitutivo*. Nonostante questo non possiamo considerare questo metodo sicuro perché tramite **crittoanalisi** il messaggio rimarrebbe facilmente decifrabile. Nella sua **variante con chiave** solo *parte dell'alfabeto sostitutivo viene generato casualmente*, il *resto* è dato dalle *lettere dell'alfabeto originale traslate di un offset pari alla dimensione della chiave*. I due hanno la *stessa robustezza*, tuttavia ***quello con chiave è preferibile*** in quanto può essere *concordata dalle due parti*.

##### Crittoanalisi

Consiste nello studio dei crittogrammi per svelarne il contenuto, viene effettuata per **statistica** o per **frequenza**.

###### Crittoanalisi Statistica

Eventualmente integrata con crittoanalisi per dizionario che considera le specificità del testo cifrato rispetto alla tematica trattata: ogni settore (medico, informatico, militare, ecc...) ha sue parole chiave, forme, utilizzo o meno di parole straniere, ecc... Il **problema** della **sostituzione mono-alfabetica** è che ***non modifica le frequenze relative delle lettere***, quindi per la crittoanalisi è possibile *calcolare la frequenza di una lettera in una determinata lingua*. Avendo a disposizione il testo cifrato, è possibile anche in esso guardare quali sono le lettere che si ripetono. Si possono ottenere così *due istogrammi simili*, andando ad accoppiare le lettere del testo cifrato con la loro frequenza nella lingua a cui appartiene il messaggio è possibile decodificare il testo per tentativi.

Inoltre è possibile determinare:

- Lettere doppie.
- Affinità delle lettere: `q` seguita da `u`.
- Non affinità delle lettere: `n` mai prima di `p`.
- Spazi significativi nelle frasi (anche se questo problema fu superato eliminando gli spazi o introducendoli ogni gruppo fisso di lettere).

In sintesi, la debolezza dei cifrari monoalfabetici sta nel fatto che, anche se cambiano una lettera con un'altra, non possono cambiare la "identità" di ciascuna lettera, e le proprietà del linguaggio del messaggio.

##### Algoritmi Polialfabetici

Introducendo più alfabeti si può generare un testo più difficile da crittoanalizzare, ad esempio usando 4 alfabeti `A1, A2, A3, A4` la prima lettera viene codificata con la prima lettera di `A1`, la seconda con la prima di `A2` e così via... Così facendo *si elimina l'evidenza delle frequenze* delle lettere più popolari. Il **cifrario di Vigenère** (1586) è in pratica un cifrario di Cesare multiplo, si utilizza una chiave di `d` lettere: $K=k_1,k_2,...,k_d$ dove l'i-esima lettera specifica l'i-esimo alfabeto da utilizzare. Si utilizza un alfabeto per ogni lettera da cifrare ripetendo la chiave se (come tipicamente accade) il testo è più lungo di `d` lettere. Per semplificare le operazioni di cifratura/decifratura si può utilizzare la cosiddetta **Tavola di Vigenère**. Questo cifrario è stato considerato sicuro per più di tre secoli (anche se non molto adottato per la lentezza di gestione) ma verso metà del 1800, Babbage e **Kasiski** ne individuarono il punto debole: "puntare prima a identificare la **lunghezza** della chiave": i simboli a distanza pari alla lunghezza della chiave sono cifrati con lo stesso alfabeto. Così facendo possiamo applicare un algoritmo di crittoanalisi ad ogni sotto testo appartenente ad ognuno degli alfabeti di sostituzione. Un ulteriore metodo di crittografia è lo **`XOR`** che come operatore binario restituisce vero quando uno solo dei due operandi è vero, mentre in termini alfabetici opera come **somma modulare**: somma degli indici delle due lettere, `mod(26)`. Idealmente per avere un crittogramma sicuro, bisogna avere una **chiave lunga quanto il testo da cifrare**. Sempre Vigenère propose il cifrario **auto-chiave** (a chiave auto-generatrice) nel quale la chiave scelta era concatenata con il testo da cifrare per avere una chiave di esecuzione sufficientemente lunga e non ripetuta.

###### One Time Pad

Il One Time Pad (OTP) è l'unico strumento di cifratura incondizionatamente sicuro, fa uso di un blocco usa e getta, che fornisce una chiave lunga quanto il messaggio (quindi, mancanza di ricorrenze). L'**idea originaria** era che ogni pagina del blocco contiene una lista di numeri casuali (es. chiavi di 30 caratteri) e per cifrare un messaggio, il mittente deve staccare tanti fogli quanti ne sono necessari a cifrare tutto il testo (es. 11 fogli per un messaggio di 330 caratteri). Mittente e destinatario devono avere un **copia identica** del blocco e usarlo in modo perfettamente sincronizzato. Teoricamente, ogni sistema basato su ripetizione è critto-analizzabile ma OTP **non** usa ripetizione, poichè ogni lettera del messaggio originale è accoppiata a un numero casuale differente, il testo cifrato risultante è **incondizionatamente sicuro** rispetto a attacchi linguistici, di ricorrenza o di dizionario. OTP è incondizionatamente sicuro ammesso che: il pad non è mai riutilizzato e i numeri casuali sono statisticamente impredicibili. Un **libro** è una fonte di "simboli casuali" sufficientemente lunga per implementare nella pratica la tecnica del blocco usa e getta. Mittente e destinatario devono mettersi d'accordo su libro, pagine, righe, frequenza lettere... I **problemi** dell'OTP sono che si basa sulla casualità della chiave: se la sequenza è veramente casuale, il crittogramma non è soggetto ad attacchi, altrimenti si, inoltre ci sono vari problemi di realizzazione:

- Generare enormi quantità di chiavi casuali
- Estremamente complesso distribuire a tutti gli interlocutori blocchi sufficientemente lunghi di chiavi per trasmettere tutti i messaggi necessari
- La protezione del pad da copie e furti

I cifrari tendono a ricreare **approssimazioni** dell'OTP, inizialmente in modo meccanico, poi in modo elettronico. Con i computer si possono generare "blocchi" di chiavi molto lunghi mediante generazione di numeri pseudo casuali, rendendo quindi possibile l'implementazione di un cifrario OTP **ma** dato che la generazione dei numeri casuali ha natura algoritmica non sarebbe un OTP con caratteristiche di inviolabilità.

### Cifrari per Trasposizione

L'obiettivo della **trasposizione** è la diffusione, spargendo le informazioni del messaggio nel testo cifrato. In pratica le trasposzioni cercano di spezzare gli schemi stabiliti, riorganizzando i simboli di un messaggio cifrato allo scopo di evitare la crittoanalisi delle adiacenze. Un esempio di trasposizione è quando Galileo Galilei, per salvaguardare le sue scoperte astronomiche, le annunciava per mezzo di anagrammi. Un altro esempio storico è lo **scitale** un cilindro, tipicamente di legno, usato inizialmente dagli spartani per scambiarsi messaggi segreti. Sullo scitale veniva avvolta una striscia di cuoio o stoffa su cui si scriveva il messaggio in orizzontale, il crittogramma si otteneva svolgendo la striscia e poteva essere interpretato solo se il destinatario avesse posseduto uno scitale uguale a quello di partenza. La trasposizione può avvenire anche **in colonna**: si scrivono i caratteri di un testo in chiaro su righe di cinque caratteri, una sotto l'altra e il testo cifrato viene ottenuto leggendo le colonne dall'alto verso il basso.

### Cifrari Prodotto

Combinando sostituzione e trasposizione si ottiene un cifrario più complesso, spesso si combinano in maniera alterna, sostituisco, traspongo, sostituisco, traspongo... Con due sostituzioni si ottiene un cifrario per sostituzione più complesso, lo stesso vale per due trasposizioni, **ma** con una sostituzione seguita da una trasposizione si ottiene un cifrario completamente nuovo e **molto più robusto**. Questa combinazione rappresenta il ponte tra la crittografia classica e quella moderna.

#### Cifrario ADFGVX

Cifrario storico che abbina le due tecniche usato durante la prima guerra mondiale. A ciascuna lettera del testo in chiaro corrisponde una coppia di lettere di una matrice costruita appositamente (es. **`ADFGVX`** sulle righe e sulle colonne). Dopodiché il *messaggio cifrato viene scritto in righe e colonne* e *si associa un ordine alle colonne della matrice*. L'ordine può essere dato seguendo l'ordine alfabetico del testo in chiaro o utilizzando una *chiave*. Con una *chiave di $n$ caratteri* il testo cifrato viene diviso su $n$ colonne. Questo metodo presenta dei limiti: effettua *un solo passo di sostituzione e trasposizione*, la *tabella di sostituzione è fissa e non dipende dalla chiave*.

## Crittografia Simmetrica e Hashing

### Macchine cifranti

Una volta compresi i vantaggi della cifratura, vi era il problema di *automatizzare multipli step di sostituzione e trasposizione* che sarebbero stati molto lenti e complessi da realizzare a mano correttamente. Si sono quindi realizzate delle *macchine a rotori* la cui *chiave* era la *posizione iniziale dei rotori*. La più famosa di queste macchine è **ENIGMA** (Germania), quando veniva utilizzata un operatore digitava le lettere che costituivano il messaggio sulla tastiera e i meccanismi interni della stessa trasformavano quel testo in un altro cifrato. Uno dei componenti all'interno della macchina era lo scambiatore: un disco di gomma attraversato da una rete di fili provenienti dalla tastiera, che dopo un percorso formato da vari incroci, emergono dalla parte opposta; lo *schema interno del rotore determina un alfabeto* cifrante (26 posizioni possibili) per sostituzione **monoalfabetica**. Il rotore scattava di un ventiseiesimo dopo ogni lettera, così facendo l'alfabeto cifrante cambiava dopo ogni lettera (da sostituzione mono a polialfabetica). A questo punto sono introdotti un secondo e terzo scambiatore: il secondo compie una rotazione parziale soltanto dopo che il primo ha compiuto un intero giro e il terzo fa lo stesso rispetto al secondo rotore. La **chiave** in questo caso è la ***posizione iniziale dei rotori*** e dalla ***posizione dei cavi che collegano i tasti al rotore***.  Infine, i **rotori sono rimovibili** (sostituibili, Enigma veniva fornita con una *scatola contenente 5 rotori*) e c'è un pannello chiamato **stecker** posto tra la tastiera e il primo rotore: permette di inserire cavi muniti di spinotti che avevano l'effetto di scambiare due lettere prima della loro immissione nel rotore. Combinando tutti gli elementi si ottiene un totale di ~106 biliardi di configurazioni possibili. Per "sconfiggere" ENIGMA gli inglesi costruirono una macchina in grado di violare "con forza bruta" i messaggi codificati.

### Crittografia Moderna

Il passaggio alla crittografia moderna è dato dall'avvento della *digitalizzazione*: con la gestione dei dati in forma **binaria**, **tutto diventa cifrabile**: foto, video, suono, testo, ecc...

> **Principio di Kerchoff**
>
> Se le *chiavi* sono scelte bene, di lunghezza adeguata, *tenute segrete*, gestite unicamente da sistemi fidati, **allora** *non ha importanza mantenere segreti gli algoritmi di crittografia*, anche perché la crittoanalisi non ha bisogno di conoscere il cifrario e i *cifrari pubblici aiutano ad individuare quanto prima eventuali debolezze*.
>
> Differenza sostanziale con la crittografia classica che puntava alla segretezza sia della chiave sia dell'algoritmo.

Gli algoritmi di crittografia *moderni* sulla base di come vengono utilizzati si suddividono in:

1. Algoritmi a chiave simmetrica (a chiave privata)

   - A blocchi: cifrano e decifrano i messaggi in blocchi, tipicamente di 64 bit o più. Il blocco deve essere tutto disponibile prima della cifratura. Esempi: DES, AES
   - A flusso: cifrano i messaggi un bit o un byte alla volta, quindi la cifratura è un flusso continuo. Esempi: RC4, Chacha20. Per certi versi sono cifrari a blocchi con blocchi molto piccoli.

2. Algoritmi a chiave asimmetrica (a chiave pubblica): RSA, ECC

### Cifrari a Blocchi

Un blocco di $n$ bit in chiaro viene trasformato in uno cifrato di $n$ bit. Questi cifrari appaiono come un *processo di sostituzione di tutti i bit del blocco*.  Con $n$ bit, quindi ci sono $2^n$ possibili blocchi in chiaro e, affinché il processo sia reversibile, ciascuno deve dare origine a **un solo** dei $2^n$ blocchi cifrati. Quindi con $n$ bit ci sono $2^n!$ chiavi possibili (trasformazioni reversibili), dati dal *numero di permutazioni possibili dei blocchi di input*.

#### Problemi del Cifrario Ideale

Il cifrario è equivalente a un classico meccanismo di sostituzione, che è vulnerabile a crittoanalisi statistica. Questa debolezza si evidenzia per n grandi, mentre per blocchi piccoli le caratteristiche statistiche del testo in chiaro sono mascherate, al punto che la crittoanalisi statistica non funziona. Il problema è che il cifrario ideale è impraticabile dal punto di vista implementativo:

- Per un blocco di 4 bit, serve una chiave lunga (4bit$\cdot$16righe=64bit)
- In generale, la lunghezza della chiave è $n\cdot2^n$ bit, che per un tipico blocco di 64bit, risulta essere $10^{21}$ bit &rarr; **improponibile**

**Shannon** studia come superare i problemi della crittoanalisi statistica e i problemi implementativi del **cifrario ideale** e giunge a definire due concetti:

- **Diffusione**: La struttura statistica del testo in chiaro deve essere mascherata dalla statistica a largo raggio del testo cifrato: **ogni bit** del testo **cifrato** deve essere influenzato da **molti bit** del testo in **chiaro**.
- **Confusione**: Riguarda la complessità della chiave. Il modo con cui è stato ottenuto il testo cifrato per mezzo della chiave deve essere talmente complesso da non consentire di risalire alla chiave originaria. Si ottiene con un algoritmo di **sostituzione** complesso.

#### Cifrari a Blocchi - Feistel

Risolve il problema del "cifrario a blocchi ideale" utilizzando due concetti: cifrario prodotto e idee di Shannon su diffusione e confusione. In pratica Feistel propone una **approssimazione del cifrario a blocchi ideale** che sia effettivamente implementabile:

- Il cifrario ***alterna sostituzioni e permutazioni*** (*cifrario prodotto*) dei bit
- Si utilizza una **chiave di $k$ bit** (gestibile) **per blocco di $n$ bit** ($2^k$ possibili trasformazioni invece di $2^n!$)

##### Cifrare con Feistel

L'algoritmo è composto da un *certo numero di round*. La **chiave** utilizzata ***cambia ad ogni round***. Il blocco viene suddiviso in **2 parti** come segue:

1. Si effettua una **sostituzione** sulla parte sinistra utilizzando l'output di una funzione (usando la chiave come parametro) applicata alla parte destra.
2. Si effettua una **permutazione** che scambia le due metà.

###### Feistel - Lucifer (Procedimento)

**input**: testo di lungezza $2w$ bit, chiave $K$, funzione $F$ che seleziona alcuni bit, ne duplica alcuni e li permuta.

- Utilizza **n** cicli, in ciascuno dei quali (**i-esimo**) si ha:

   1. input: $L_{i-1}, R_{i-1}$ e chiave $K_i$
   2. Sostituzione sulla ***parte sinistra***:
      - Si applica la funzione $F$ che consiste in una *somma a modulo 2* tra la chiave $K_i$ e la parte destra $R_{i-1}$
      - Si effettua XOR (*sostituzione*) tra l'output di questa funzione e $L_{i-1}$
   3. Permutazione che consiste nello scambio tra le due parti

- Quindi si prosegue nello stesso modo:

   1. $L_{i+1}=R_i$
   1. $R_{i+1}=L_i\oplus F(R_i,K_{i+1})$
   1. Il testo cifrato finale è una giustapposizione di $L_{n+1}$ e $R_{n+1}$

In pratica un cifrario di Feistel è un cifrario prodotto che utilizza tre funzioni base: **S-box** (sostituzione), **XOR** e **P-box** (permutazione). L'efficacia del cifrario di Feistel dipende dalla **scelta** di vari parametri: dimensioni del blocco e della chiave, numero di cicli e scelta della funzione di sostituzione $F$.

##### Decifrare con Feistel

**Analogo** al processo di cifratura: utilizza il testo cifrato come input e le chiavi $K_i$ in ordine inverso: $K_n$ nel primo ciclo, $K_{n-1}$ nel secondo e così via, fino $K_1$. Questa è una proprietà **molto importante** perché non si ha la necessità di progettare e implementare due algoritmi e (eventuali) circuiti differenti.

La maggior parte dei ***cifrari a blocchi moderni*** (DES, 3DES, AES) sono ***basati sui principi del cifrario di Feistel*** e sulle sue derivazioni di S-box e P-box.

#### Cifrari a Blocchi - DES (Data Encryption Standard)

L'algoritmo in se' si chiama Data Encryption Algorithm (DEA) ma la terminologia è un po' confusa e tutti lo chiamano DES, si tratta dello *standard americano*. Questo algoritmo **lavora a blocchi di 64 bit**, con **chiave a 64 bit** (in realtà 56 con 8 bit di controllo parità). Similarmente a Feistel applica ripetutamente tecniche di sostituzione (S-box) e trasposizione (P-box), per un totale di **16 cicli**. DES è composto da **3 fasi**:

1. Permutazione inziale
2. *16 cicli* di trasformazioni che implicano sia *S-box* che *P-box*
3. Parte dx e sx dell'output sono scambiate (*pre-output*) e passate ad una funzione di permutazione (*inversa di quella iniziale*)

> Con eccezione delle fasi iniziali e finali e del trattamento della chiave, la struttura DES è identica a quella di Feistel.

**Trattamento della Chiave**: Per ciascuno dei 16 cicli si genera una *sotto-chiave $K_i$ differente di 48 bit* mediante i seguenti passi: si utilizzano i 56 bit della chiave $K$ che viene suddivisa in 2 parti, e si effettua uno shift circolare a sinistra, passo tutto a una funzione di permutazione e contrazione (da 56 a 48 bit) e infine effettuo uno XOR bit a bit con la parte destra del blocco da cifrare (32 bit) che nel frattempo è stata espansa a 48 bit.

Come per ogni cifrario basato su Feistel, l'algoritmo di decifrazione utilizza lo stesso procedimento di quello di cifratura. Fin dall'inizio si mise in dubbio l'inviolabilità di DES e la scelta di una chiave a soli 56 bit contro i 128 usati dai Lucifer, una parte della struttura interna dell'algoritmo (le S-Box) era ***classified***. Il DES è il cifrario **più crittoanalizzato della storia**, le versioni successive del DES sono molto più sicure e robuste. Un motivo della **robustezza** del DES è l'**effetto a valanga** ovvero la sua proprietà di far corrispondere al cambiamento di un bit non cifrato molti cambiamenti nel testo cifrato. Il DES non può ancora essere considerato del tutto superato, ma le sue vulnerabilità diventano sempre più concrete, ciò ha indotto il NIST a operare su:

1. Potenziare il DES
2. Individuare un nuovo standard: AES

##### 2DES

Potenziamento di DES, consiste nell'**utilizzo di due chiavi** $K_1$ e $K_2$, per ottenere un messaggio cifrato $C$, si eseguono due crittografie DES ($E$) in successione sul testo in chiaro $P$ in questo modo: $C = E(K_2, E(K_1,P))$. Per ottenere un messaggio in chiaro, si eseguono due decifrazioni DES ($D$) in successione sul testo cifrato: $P=D(K_1, D(K_2, C))$. L'**idea** del 2DES è avere una ***robustezza pari all'utilizzo di una chiave doppia***: $2^{56}+2^{56} = 112 \text{ bit}$ . In realtà con l'attacco **meet-in-the-middle** si è dimostrato che le difficolta della crittoanalisi a forza bruta per 2 DES sono solamente raddoppiate. Non si ha un incremento esponenziale come si pensa, ma la complessità aumenta semplicemente a $2^{57}$.

###### Meet-in-the-Middle

Se si conosce la coppia $(P,C)$ ovvero testo in chiaro e cifrato corrispondenti, vale la relazione: $C=E(K_2, E(K_1,P))$ e $X=E(K_1,P)=D(K_2,P))$.

**Attacco:** si cifra P per tutti i possibili $2^{56}$ valori della chiave $K_1$, si memorizzano i risultati in una tabella ordinata per valore di i . Si decifra $C$, usando tutti i possibili $2^{56}$ valori della chiave $K_2$ e per ogni valore prodotto, si controlla se c'è un valore corrispondente nella tabella, se si trova, si è trovata anche la chiave.

##### 3DES

L'idea immediata sarebbe utilizzare tre passi di cifratura con tre chiavi differenti però una *chiave di 168 bit era poco praticabile con la tecnologia degli anni 70/80*. **3DES** o Triple DES consiste nell'**uso di due chiavi e l'applicazione di tre operazioni**: Encrypt-Decrypt-Encrypt (EDE) sul testo in chiaro: $C = E (K_1, D(K_2, E(K_1, P)))$ Si esegue la *crittografia con una chiave*, la *decifrazione con la seconda* e una *nuova crittografia ancora con la prima chiave*. L'obiettivo del 3DES è quello di raddoppiare la complessità della crittoanalisi a forza bruta (come se la chiave fosse di 112 bit) l'effettivo livello di sicurezza è stato stimato in $2^{80}$. Con la *tecnologia odierna 3DES viene applicato con 3 chiavi*, una per ogni passaggio con un livello di sicurezza stimato di $2^{112}$ rispetto alla complessità di $2^{168}$.

#### Cifrari a Blocchi - AES (Advanced Encryption Standard)

Nel 1997 il NIST lancia la sfida per un nuovo sistema di crittografia non segreto. Vengono fatte diverse proposte da privati e aziende. Viene scelto l'algoritmo con un buon livello di sicurezza e di facile implementazione software, che verrà standardizzato come AES. L'algoritmo viene suddiviso in round, ogni round è composto da 4 cicli:

1. Il **blocco iniziale di 128 bit** e la chiave sono rappresentati come una ***matrice di byte***: si inizia con la ***sostituzione dei byte*** del blocco iniziale con una tabella di sostituzione (tutto il blocco e non metà come in Feistel e DES)
2. Shift delle righe
3. Mescolamento delle colonne
4. Aggiunta della sottochiave

Ciascun passo è *ripetuto 9, 11 o 13* volte a seconda se si utilizzano *chiavi di 128, 192 o 256 bit*. La chiave iniziale infatti viene espansa in 9, 11 o 13 chiavi diverse da utilizzare in ogni round.

Ipotizziamo l'utilizzo di una chiave a 128 bit e vediamo come funziona l'algoritmo:

1. Input: un blocco di 128 bit
    - Rappresentato come una matrice di byte
    - Il blocco è copiato in uno state array modificato ad ogni passo
    - Dopo il ciclo finale, lo state array è copiato nella matrice di output
2. La chiave di 128 bit è anch'essa rappresentata come una matrice di byte
    - espansa in un array di **key schedule word**, una ogni 4 byte
    - In totale, si usano 44 word per una chiave di 128 bit
3. Byte ordinati per colonna
    - I prmi 4 byte del testo in chiaro (di 128 bit) in input occupano la prima colonna della in-matrix
    - I primi 4 byte della chiave espansa occupno la prima colonna della w-matrix

La chiave è espansa in un array di 44 parole di 32 bit: `w[i]`, 4 word (128 bit) servono come **round key** per ogni ciclo. A questo punto seguono quattro passi, una permutazione e 3 sostituzioni:

1. Sostituisci i byte usando la s-box table per eseguire una sostituzione byte by byte del blocco
2. Permutazione delle righe effettuata riga per riga
3. Mix columns: sostituzione che altera ogni byte in colonna come funzione di tutti i byte della colonna
4. Add round key: XOR bit a bit del blocco corrente con una parte della chiave espansa

Per quanto riguarda la **struttura** di AES, inizialmente, sia per cifrare che per decifrare si effettua un passo di Add Round Key, successivamente ci sono 9 cicli, ciascuno di 4 passi e per ultimo un decimo ciclo costituito da 3 passi.

### Cifrari a Flusso

Si applicano tipicamente a byte. Usano lo XOR (in modo da esser veloce e facilmente invertibili). Fanno uso della **keystream**: ogni *bit del plaintext* viene messo in *XOR con il bit corrispondente della keystream*. Per la decifratura viene utilizzato il ciphertext, messo in XOR con la keystream per riottenere il plaintext. Il cifrario a flusso tende ad assomigliare al cifrario One-Time-Pad (OTP) con la differenza sostanziale che in questo caso ***si utilizzano chiavi pseudo-casuali e non casuali***. La pseudo-casualità combinata con lo XOR cancella ogni proprietà statistica del messaggio in chiaro. Ogni due componenti consentono di risalire al terzo, avendo testo in chiaro e cifrato è possibile ricavare la chiave e avendo due testi cifrati con la stessa chiave è possibile ricavare lo XOR dei due testi in chiaro quindi, non bisogna mai riutilizzare la stessa stream key su due testi in chiaro differenti e la ***stream key deve cambiare continuamente***.

La stream key deve:

- approssimare le proprietà statistiche di una vera sequenza di numeri casuali: più è ***randomizzata*** la chiave e più difficile è la crittoanalisi.
- essere ***calcolata*** a partire ***da una chiave sufficientemente lunga*** per evitare i rischi di attacchi di forza bruta (almeno 128 bit)
- derivare da una sequenza di numeri pseudo-casuali con il **periodo** più **lungo** possibile

Con un buon generatore di numeri pseudo-casuali, un cifrario a flusso può essere tanto sicuro quanto un cifrario a blocchi, con il **vantaggio** di essere molto più ***veloce*** e richiedere molto ***meno codice software***.

#### Cifrari a flusso - RC4

Orientato a flussi di byte. L'algoritmo dopo una fase di inizializzazione effettua una **permutazione casuale** di ciascuno degli 8 bit, ***basata sulla chiave***. Il **periodo** è **molto grande**, superiore a $10^{100}$. RC4 è stato utilizzato in SSL, WEP e WPA, gestione password Windows.

In realtà sono state identificate delle debolezze nel PNRG:
- I primi 256 byte del keystream non sono veramente random, molte implementazioni li scartavano eseguendo i primi 256 cicli a vuoto
- Correlazione troppo forte tra chiave e keystream
- Queste debolezze sono il principale motivo per cui una chiave WEP è facilmente violabile. RC4 ad oggi è deprecato.

##### Funzionamento

Fattori necessari:
- **Chiave variabile** da 1 a 256 byte
- **Vettore di stato $S$** di 256 elementi contenente una permutazione dei valori dei byte da 0 a 255, 255
- **Vettore temporaneo $T$** di 256 byte, inizialmente contenente la chiave (ripetuta tante volte quante sono necessarie per riempire T)

Si utilizza il *vettore T per produrre la permutazione iniziale di S*, ogni elemento `S[i]` viene scambiato con un altro byte $j$ secondo quanto indicato da `T[i]`: $j = j+T[i]+S[i]$. Dopo 256 operazioni di questo tipo il risultato è un *vettore di stato molto ben mescolato*. A questo punto la chiave $K$ e il vettore $T$ non sono più utilizzati e inizia la cifratura.

1. La cifratura avviene continuando a scambiare i valori degli elementi del vettore di stato $S[i]$ e $S[j]$.
2. Gli elementi selezionati per lo scambio vengono anche sommati (modulo 256) per calcolare $t=S[i]+S[j]$. Questo viene utilizzato come indice nel vettore di stato $S$ e il valore corrispondente viene utilizzato come *valore della "stream key"*.
3. Si effettua XOR tra questo valore e il byte del messaggio

RC4 è soggetto a **bit flipping attack**: l'attaccante può prendere il ciphertext e modificarne un byte, poiché la *corrispondenza tra un byte del plaintext e uno del ciphertext viene mantenuta*. L'integrità del messaggio in questo modo non è più assicurata ed è possibile manipolare il flusso di bit anche senza doverlo decifrare tutto, questo risulta pericoloso in schemi di comunicazione rigidi (es. *sistemi bancari*).

### Integrità

Fino ad ora l'attenzione è stata focalizzata sulla "riservatezza" del messaggio (crittografia) e indirettamente sull'autenticazione dell'identità mittente (chiave segreta) ma quando si vuole instaurare un canale di comunicazione sicuro ci sono diversi aspetti da tenere in considerazione:

1. Riservatezza dei dati: se qualcuno intercetta un messaggio non deve essere in grado di leggerlo
2. Autenticazione identità mittente: come faccio a sapere che chi mi scrive è colui che dice di essere?
3. Integrità dei dati: come so che il messaggio che ricevo è uguale all'originale inviato?
4. Ripudio all'origine: se il mittente ripudia l'invio del messaggio?
5. Ripudio a destinazione: se il destinatario ripudia la ricezione del messaggio?

Ci sono *protocolli di crittografia orientati proprio all'autenticazione del messaggio*, gli obiettivi sono validare l'integrità del messaggio e la sua autenticazione (identità della sorgente, inclusa la non ripudiabilità all'origine). Queste operazioni vengono fatte tramite funzioni di hash con o senza chiave segreta. Giustapponendo un **digest** ad un messaggio il destinatario può verificarne integrità quando lo riceve ricalcolando il digest e confrontandolo con quello originale, le **funzioni di hash** *servono per generare i digest*.

#### Funzioni di hash

1. La funzione $h(m)=y$ deve avere *bassa complessità computazionale* nel calcolo del digest di un messaggio
2. Non invertibilità
3. Resistente alle collisioni: due $m$ diversi non possono avere lo stesso hash
4. La funzione $h$ deve distribuire i digest in modo uniforme per ogni messaggio $m$

È impossibile trovare una funzione hash *incondizionatamente resistente alle collisioni*, ci si accontenta di trovarne una ***computazionalmente resiste alle collisioni***. Creare una funzione hash, di per se' è banale, è crearne una *sicura* che è difficile. Una semplice funzione di hash potrebbe essere implementata nel seguente modo: dato un messaggio **m** lungo **L** bit, si vuole ottenere un digest di **n** bit (tipicamente $L>>n$)

1. Si suddivide il messaggio in blocchi di **n** bit in modo tale che $k=L/n$ (eventualmente si completa l'ultima riga con zeri per avere blocchi uguali)
2. Si dispone ciascun blocco su una riga, in modo da avere una matrice $n\times k$
3. La funzione hash $h(m)$ è formata dagli **n** bit, dove il bit i-esimo è ottenuto dallo XOR degli elementi della i-esima colonna, cioè: $h_i=m_{1i}\oplus m_{2i}...\oplus m_{ki}$

Chiaramente questa soluzione non è robusta e presenta un alta probabilità di **collisione**.

##### Message Digest (MD)

La famiglia di funzioni MD si deve a Ron Rivest, la prima versione non fu mai pubblicata, sono stati diffusi MD2 e MD4, sostituita poi con MD5. Quest'ultima restituisce un digest di 128 bit, dopo 10 anni di tentativi, verso il 2004, si sono individuati meccanismi di crittoanalisi che hanno avuto successo evidenziando collisioni per MD5 che pertanto è oggi in uno stato di "not recommended" nei documenti IETF.

##### Secure Hash Algorithm (SHA)

Sviluppato dalla NSA e raccomandato dal NIST, la versione SHA-0, pubblicata nel 1993, conteneva una debolezza che ha portato alla versione SHA-1, quest'ultima è stata utilizzata in moltissime applicazioni e protocolli (SSL, PGP, SSG, S/MIME, IPSec). **SHA-1** produce un digest di 160 bit da un messaggio con una lunghezza massima di $2^{64}-1$ bit, si basa sulla stessa idea di una procedura iterativa usata da MD4 e MD5: si inizia a costruire una matrice come nel caso semplice visto, i blocchi del messaggio sono elaborati mediante una serie di *cicli* che *usano una funzione di compressione* che combina il blocco corrente con il risultato ottenuto nel round precedente. La robustezza di SHA-1 risiede nella definizione di una ***buona funzione di compressione*** &rarr; deve essere costruita in modo che *ogni bit di input influenzi il maggior numero di bit di output*. Nel 2005, gli stessi ricercatori cinesi (Wang et al.) che hanno violato MD5 hanno dimostrato che si possono trovare collisioni a forza bruta per SHA-1 con una complessità di "solo" $2^{69}$ invece del previsto $2^{80}$. Già dal 2001, esiste **SHA-2**, in seguito, come per il DES, nel 2007 il NIST ha lanciato un public contest per il nuovo algoritmo **SHA-3**.

##### Whirlpool

Proposto da Barreto e da Rijmen, co-autore di AES, prende in **input** un messaggio di lungezza massima di **$2^{256}$bit** e restituisce un digest di **512bit (64Byte)**. Si basa su una cifratura a blocchi quadrata (analoga a quella di AES) e 10 round.

#### Funzioni MAC

Le funzioni di hash che non utilizzano una chiave ci danno solo la garanzia che il messaggio non è stato alterato durante la trasmissione. Non ci da alcune informazioni relative al mittente (hash != firma). Esistono funzioni in grado di combinare le tecniche di hash con una chiave: **MAC** Message Authentication Code. Una funzione MAC prende in input un ***messaggio*** e una ***chiave segreta***, e genera un **TAG**, che viene utilizzato dal destinatario per verificare l'autenticità e l'integrità del messaggio.  Un *attaccante* che vuole modificare un messaggio deve inviare anche il TAG calcolato con la chiave segreta. Per combinare hash e chiave ad esempio basterebbe fare $H(K,H(K,m))$ dove $H$ è una funzione di hash, $K$ la chiave e $m$ il messaggio. A questo punto se mittente e destinatario condividono la chiave segreta $K$ possono verificare **integrità** e **autenticità** del messaggio. Una funzione MAC è una funzione **molti-a-uno**, monodirezionale simile, per certi aspetti, a un hashing e per altri alla crittografia simmetrica, con una differenza significativa: **non deve essere reversibile**.

> NB: una funzione MAC **non è una firma digitale** in quanto entrambi gli *interlocutori condividono la stessa chiave* $K$ e quindi non si ha garanzia dell'univocità del mittente.

Più messaggi (lunghi) potrebbero dare origine allo stesso MAC che è di qualche byte, una funzione MAC buona rende le collisioni rare e rende computazionalmente impossibile da determinare una collisione.

##### HMAC

HMAC utilizza come MAC quello derivato da una funzione di hashing `H` applicata alla concatenazione tre la chiave `K` (con eventuale padding) e la stessa funzione di hashing applicata alla concatenazione della chiave (con eventuale padding) e del messaggio: $TAG=HMAC(K,m)=H(K||H(K||m))$ dove `H` può essere una qualsiasi funzione di hashing per crittografia. Più in dettaglio: $HMAC(K,m)=H((K\oplus pad)||H((K\oplus pad)||m))$


## Crittografia Asimmetrica

### Problemi della crittografia simmetrica

Per garantire la sicurezza degli algoritmi visti fino ad ora bisogna affrontare il **problema di distribuzione delle chiavi**. Per il funzionamento della crittografia simmetrica i due interlocutori devono ricevere o scambiarsi la stessa chiave e proteggerla da terzi. Il processo di *distribuzione delle chiavi è il "tallone di Achille"* dei meccanismi di cifratura simmetrica.

Supponiamo che alice voglia instaurare un protocollo di comunicazione sicuro con bob. Tipici problemi di Alice:

- Distribuzione delle chiavi
    - Come ricevo la chiave di Bob?
    - Come consegno la mia chiave a Bob?
- Verifica della chiave condivisa
    - Quella che ottengo è veramente la chiave di Bob?
- Memorizzazione della chiave
    - Dove memorizzo la chiave di Bob in modo sicuro, tenendo conto che ogni copia causa una vulnerabilità?
- Controllo della validità
    - La chiave di Bob è ancora valida?
    - La mia chiave è stata compromessa; come informo Bob?

1. La *consegna fisica* è il modo *più semplice e più sicuro*, ma è applicabile solo nel caso di possibilità di contatto tra i due interlocutori, o tra una terza parte e ciascun interlocutore.
2. Nel caso in cui i due interlocutori abbiano già stabilito in precedenza un canale sicuro, possono utilizzare la chiave precedente per cifrare una nuova chiave
3. Analogamente, nel caso in cui gli interlocutori abbiano un canale di comunicazione sicuro con una terza parte (trusted courier)

Sono stati sviluppati i **Key Distribution Center** (***KDC***) con l'intento di *superare i problemi connessi alla trasmissione delle chiavi*.

1. L'host invia un pacchetto che richiede una connessione
2. Il FrontEnd richiede al KDC una chiave di sessione
3. Il KDC distribuisce la chiave di sessione a entrambi i FrontEnd
4. Vengono trasmessi i pacchetti tra i due host

Ci sono quindi due livelli di chiavi:

1. Una **chiave di sessione**, temporanea, utilizzata per la durata di una connessione logica e poi scartata.
3. Una **chiave master** condivisa dal Key Distribution Center e il sistema utente utilizzata per cifrare le chiavi di sessione.

Questo approccio ha funziona bene in piccole realtà ma non è scalabile. Quale potrebbe essere un'altra soluzione?

#### Possibili Soluzioni

- Il mittente prende una scatola con doppia chiusura mette l'informazione da proteggere nella scatola, chiudendo il lucchetto di cui solo lui ha la chiave e la spedisce al destinatario
- Il destinatario chiude il secondo lucchetto di cui solo lui ha la chiave e la rispedisce al mittente
- Il mittente toglie il proprio lucchetto e spedisce al destinatario
- Il destinatario può aprire la scatola e leggere il messaggio

Questo metodo in generale funziona, però *non è compatibile con la cifratura* mediante computer: applicare il lucchetto sarebbe cifrare il messaggio, quindi anche se è possibile rimuovere il lucchetto mentre c'è l'altro sulla scatola, *non è possibile rimuovere la cifratura dopo che ne è stata applicata un'altra*, matematicamente i due processi di cifratura **non sono commutativi**. Vediamo quindi un'alternativa:

- Supponiamo di avere diversi lucchetti identici di cui solo noi abbiamo la chiave
- Possiamo spedirli aperti a chi voglia inviarci un messaggio sicuro
- Chiunque volesse inviarci un messaggio, prenderebbe una scatola, metterebbe il messaggio, chiuderebbe con il lucchetto e spedirebbe il messaggio
- Fino a quando l'unica copia della chiave rimane in nostro possesso, distribuire i lucchetti non compromette la sicurezza

Il problema di questo approccio è che *distribuire tanti lucchetti è costoso*. Esiste una chiave che io possa distribuire e che le persone possano utilizzare per cifrare messaggi che solo io possa decifrare? Devo creare un sistema di cifratura **asimmetrica** che usi *una chiave per cifrare ed un'altra per decifrare*. Distribuire tanti lucchetti aperti è costoso, distribuire *una chiave pubblica ha un costo irrisorio*.

#### Crittografia Asimmetrica - RSA

Lo schema concettuale fu introdotto pubblicamente per primi da **Diffie** e **Hellman** (Stanford 1976) che pensarono di sfruttare una coppia di chiavi: **public-key** e **private-key**. Ogni utente è dotato di una coppia univoca di chiavi complementari: quella **pubblica** può essere conosciuta da tutti ed è usata per cifrare il messaggio, quella **privata** è tenuta al sicuro dal suo proprietario in maniera che solo lui possa usarla. Nel 1977-78 Rivest, Shamir e Adleman creano **RSA**.

##### Fattorizzazione

La prima robustezza di RSA è la **fattorizzazione**: si basa sulla difficoltà di scomporre un numero nei suoi fattori primi che è inevitabilmente un metodo a "forza bruta", non ci sono scorciatoie. Visto che il *problema di individuare un algoritmo di scomposizione è un problema aperto da secoli*, i crittografi lo considerano la ***base più solida su cui fondare un sistema di crittografia*** che non possa essere violato con metodi di crittoanalisi statistica. Si può rendere la crittografia asimmetrica **computazionalmente** **inviolabile** utilizzando numeri primi grandi a piacere.

***trattor function***: funzione facile da calcolare ma non facilmente invertibile **a meno che** si conosca il segreto. Esempio: *fattorizzazione* e *moltiplicazione*. È facile moltiplicare numeri anche molto grandi, è difficile scomporli in fattori primi, o risalire a quali due numeri ho moltiplicato per ottenere il terzo.

##### Aritmetica Modulare

La seconda robustezza di RSA sta nello sfruttare funzioni unidirezionali "semplici", l'aritmetica modulare (operatore modulo) è ricca di funzioni unidirezionali semplici. È bene scegliere *numeri primi* $p$ come *moduli* le cui potenze di 2 garantiscano una *permutazione di tutti i numeri* (da $1$ a $p-1$, come: $19$ e $101$, cercando *numeri $p$ molto grandi*). &rarr; $2^x \text{mod } p= y$. Per trovare $x$ data la coppia $(p,y)$ è necessario risolvere un ***problema di logaritmi discreti*** (*computazionalmente ingestibile*). Queste funzioni presentano interessanti proprietà quando combinate con le potenze, per esempio se $z=v+y+w$ allora $(X^z)\text{mod }q = ((X^v)\text{mod }q\times (X^y)\text{mod }q\times (X^w)\text{mod }q)\text{mod }q$

##### Funzionamento RSA

Vediamo ora nello specifico il funzionamento di RSA (Rivest, Shamir e Adleman):

1. Alice sceglie due numeri primi molto grandi da tenere segreti (nell'esempio si usano numeri piccoli): `p=17` e `q=11`
2. Alice calcola: `N=p*q 17*18=187`
3. Alice sceglie un esponente di cifratura `k=7`, possibilmente primo anch'esso, tale che `k` e `(p-1)*(q-1)` siano primi fra loro
4. Alice è libera di pubblicare `N` e l'esponente `k`: la sua *chiave pubblica*

Per determinare la chiave privata:

1. Bisogna trovare un valore per `d` tale che la seguente equazione sia soddisfatta utilizzando l'aritmetica in modulo: `(k*d) mod((p-1)*(q-1)) = 1`

   Nel caso in esame `(7*d) mod(16*10) = 1`

2. Sfruttando l'aritmetica dei moduli e l'algoritmo di Euclide `d=23`

4. Ricapitolando `pub_key: (N=187, k=7)` e `priv_key: d=23`

Per **cifrare** un messaggio quindi Bob dovrà trasformare il testo in numero (tipicamente tramite ASCII) e applicare la seguente formula: $C=(M^k)mod(N)$

Per **decifrare** il messaggio Alice: $M=(C^d) mod(N)$

Rivest, Shamir e Adleman sono riusciti a individuare quello che serviva: **una funzione unidirezionale speciale** con possibilità di essere invertita assumendo di avere qualche dato. Questa funzione:

- Permette a chiunque di cifrare un messaggio
- È unidirezionale per tutti
- È invertibile (quindi il messaggio decifrabile) da parte di chi:
   - O è in possesso delle informazioni privilegiate `p` e `q`
   - Oppure ottiene `p` e `q` scomponendo la chiave pubblica in fattori primi `N=p*q`

Il sistema RSA è **sicuro** nel momento in cui `N` ha qualche centinaio di cifre e la scomposizione supera le capacità di calcolo attuali e quelle del prossimo futuro. Dovendo usare *chiavi molto lunghe*, la crittografia asimmetrica è computazionalmente **molto più onerosa** di quella simmetrica: *servono chiavi più grandi* di almeno *1024 bit*, se non *2048* (contro i 128/256 degli algoritmi simmetrici).

##### Applicazioni

Gli algoritmi a chiave pubblica sono utili solo per attività specializzate perché sono ***molto lenti*** rispetto alla crittografia a chiave privata: una cifratura asimmetrica può richiedere 10.000 volte più tempo. I *cifrari simmetrici sono computazionalmente meno onerosi* di quelli asimmetrici per due motivi: natura computazionale degli algoritmi e necessità di *chiavi più ridotte* per avere analoghe garanzie di sicurezza. Fin quando possibile si preferisce l'uso dei cifrari simmetrici, l'uso di quelli asimmetrici va limitato a contesti specifici (es. ***scambio di una chiave simmetrica di sessione***).

#### Scambio di chiavi Diffie-Hellman

Consente a due interlocutori di calcolarsi separatamente la stessa chiave simmetrica utilizzando informazioni pubbliche (scambiate su canali insicuri). Non richiede segreti a priori e si basa sulla difficoltà di calcolare logaritmi discreti di grandi numeri. Ad oggi, non sono noti attacchi di successo al protocollo Diffie-Hellman. Vediamone un esempio:

- Alice e Bob condividono due numeri `P` e `G` e li scambiano attraverso un canale insicuro. `P` è un numero primo grande (almeno 512 bit) e `G` è un numero generatore modulo `P` (un intero tale che ogni intero primo con P è congruo a una potenza di G). $G$ è un numero con *proprietà matematiche particolari*. 
- Alice sceglie un suo numero privato **`a`**, calcola **`x=G^a modP`** e invia `x` a Bob
- Bob sceglie un suo numero privato **`b`**, calcola **`y=G^b modP`** e invia `y` a Alice
- Alice e Bob calcolano i rispettivi valori $k_a = y^a mod P$ e $k_b = x^b mod P$ che risulteranno essere uguali
- A questo punto possono cifrare tutta la comunicazione a **chiave simmetrica**

> **Esempio**
>
> Alice e Bob vogliono stabilire una conversazione sicura e decidono di utilizzare il protocolli di Diffie-Hellman:
> 1. Alice e Bob scelgono due numeri pubblici e due privati:
>
>    - `P = 23, G = 9`
>    - `a = 4,  b = 3`
> 2. Calcolano due valori che poi si scambiano
>
>    - $X = 9^4 \% 23 = 6561 \%23 = 6$
>    - $Y = 9^3 \% 23 = 729  \%23 = 16$
> 3. Alice e Bob si scambiano i valori pubblici $X$ e $Y$ e calcolano la loro chiave simmetrica con cui cifrare tutta la comunicazione
>
>    - $k_a=Y^a \% P = 16^4 \% 23 = 9$
>    - $k_b=X^b \% P = 6^3 \% 23 = 9$
>

Diffie-Hellman è utilizzato in molti protocolli (*SSH*, *SSL/TLS*, *IPSec*, PKI)

## Firma Digitale e Certification Authority

In questa sezione vedremo come combinare gli strumenti visti fino ad ora per ottenere confidenzialità, integrità, autenticazione, controllo degli accessi e non ripudiabilità.

### Garanzie sul messaggio

- Segretezza del messaggio: il mittente cifra il messaggio con la chiave pubblica del destinatario che la decifrerà con la propria chiave segreta.
- Autenticità del messaggio: il mittente cifra il messaggio con la sua chiave privata, il destinatario decifra usando la chiave pubblica del mittente.
- Integrità: il mittente invia il messaggio in chiaro allegando un *digest* (*hash del contenuto*) cifrato con la sua chiave privata. Il destinatario confronta l'hash del messaggio con quello che ottiene decifrando il digest con la chiave pubblica del mittente

La **firma digitale** permette, tramite un ***sistema di chiavi asimmetriche*** a coppia (pubblica e privata), di rendere manifesta e di verificare la provenienza e l'integrità di uno o più messaggi, applicando anche il principio di **non ripudiabilità**.

Vediamo ora come Bob può mandare un messaggio ad Alice con firma digitale:

- Bob scrive il messaggio, ne calcola l'hash, lo cripta con la sua chiave privata e lo allega al messaggio, infine cripta il tutto con la chiave pubblica di Alice e lo invia.
- Alice, una volta ricevuto il messaggio, lo decripta con la sua chiave privata e calcola l'hash del messaggio, poi decripta il digest con la chiave pubblica di Bob e lo confronta con quello da lei calcolato per verificare così autenticità, integrità e non ripudio, di un messaggio riservato solo a lei.

### Terze parti fidate

Fino ad ora abbiamo dato per scontato che le chiavi pubbliche siano tali. Ma se un attaccante si fingesse qualcun'altro dicendo che la sua chiave pubblica è di questo qualcuno?

- Nel caso in cui si parla di ***chiavi simmetriche*** la soluzione è il **Key Distribution Center** fidato
- Nel caso delle ***chiavi asimmetriche*** la soluzione è una **Certification Authority (CA)** fidata

#### CA Certification Authority

Nel sistema di crittografia pubblica (Public Key Infrastructure - PKI) prima che due entità si scambino dati usando la crittografia a chiave pubblica, ciascuno vuol essere sicuro che l'altra parte sia quella che dice di essere. Un modo per essere sicuro è affidarsi a una ***terza parte fidata***, detta Certification Authority (CA) che certifica la connessione tra Bob e la sua chiave pubblica, agisce come ***notaio del web***. La CA firma la chiave pubblica di Alice garantendo a Bob l'identità di Alice. Una CA rilascia certificati che garantiscono la connessione tra una chiave pubblica e una entità. Solitamente queste operazioni prevedono che l'entità si *presenti fisicamente presso una CA con dei documenti*: quest'operazione *ha un costo*. 

##### Rilascio CA (Certificato Digitale X.509)

Bob effettua le seguenti azioni per ottenere un certificato:

- Crea una coppia di chiavi (pub e priv)

- Cifra la propria identità ID e la propria chiave pubblica con la sua chiave privata

- Spedisce il messaggio cifrato e la propria chiave pubblica alla CA [CSR, Certificate Signing Request]

  Si dimostra così che Bob possiede la chiave privata corrispondente alla chiave pubblica e si protegge l'integrità e la confidenzialità di chiave pubblica e ID durante la spedizione su canale insicuro

La CA effettua le seguenti azioni:

- **Verifica** informaticamente **la firma di Bob** (verifica che con la chiave pubblica di Bob è possibile risalire alla coppia pubkey-id di Bob
- **Verifica l'identità** di Bob: ogni paese ha le proprie leggi a riguardo
- **Crea un certificato digitale**, che contiene tante informazioni tra cui la *corrispondenza tra la chiave pubblica e l'id di Bob*
- **Firma il certificato digitale** cifrando tutto *con la sua chiave privata*
- **Spedisce** il certificato digitalmente

A questo punto Bob:

- Verifica informaticamente il certificato digitale (con la pubkey della CA decifra e ottiene la chiave pubblica e il proprio id)
- Verifica la correttezza dei dati nel certificato digitale.

La CA pubblica un ***elenco dei certificati rilasciati e validi***, **sospesi e revocati** (*CRL - Certificate Revocation List*). Lo standard X.509 prevede l'associazione di un distinguished name (DN) a una chiave pubblica con tante informazioni aggiuntive (versione certificato, chiave pubblica DN, tipo certificato, ecc...). Un **certificato digitale** collega l'identità di un soggetto a una chiave pubblica Firmato dalla (CA).

##### Verifica CA

- La firma sul documento corrisponde al documento? Verifica dell'hash
- La chiave pubblica usata è quella del certificato? Semplice confronto automatizzato
- Il certificato corrisponde alla persona? Verifica del nome e altri dati
- La firma che valida il certificato corrisponde al certificato? Si risale la catena di autorità
- La firma sul certificato è quella di un certificatore valido?L'utente deve possedere il certificato root
- Il certificato compare nella lista del certificatore? La lista è indicata nel certificato della CA

Omettere uno qualsiasi di questi punti conduce a possibili attacchi dello schema CA

Ci sono diverse CA e quindi si possono incontrare problemi ad esempio nel caso in cui certificati diversi sono verificati da CA diverse. Solitamente i certificati delle principali società di CA sono già presenti nei browser più diffusi.

###### Certificazione "paritetica"

Consiste nello stabilire ***vincoli di fiducia reciproca tra le diverse CA***. Se due CA si fidano di un elemento in comune possono fidarsi tra loro. Se qualche CA fallisce o non viene più riconosciuta come affidabile diventa impossibile revocare le mutue autenticazioni (*complessità di gestione*).

###### Browser e CA

I ***certificati delle principali CA*** (e relative chiavi pubbliche) sono ***preinserite in tutti i browser***, così da renderli in grado di verificare la firma dei certificati provenienti dalle CA, controllare autenticità e integrità ed essere sicuri della relazione id-chiave pubblica del server. In certi casi i *certificati possono essere delegati* da CA ad altre CA: ci possono essere deleghe di responsabilità.

###### Certificate Chain

I server hanno dei certificati rilasciati da **CA intermedie**, le CA intermedie a loro volta hanno dei certificati rilasciati da una CA intermedia o una **CA root**, quest'ultime sono note e riconosciute dai vari sistemi operativi. Per verificare un certificato, il client deve verificare tutti i certificati presenti in una catena, fino a quando ne trova uno noto e fidato.

##### Revoca CA

Tutti i **certificati scadono**, il *client valida la data di scadenza* per verificare che il certificato sia ancora utilizzabile. Non è possibile modificare la data di scadenza senza ***rompere*** la firma digitale. Come si fa a notificare la revoca di un certificato che non dovrebbe più essere utilizzato? Ad esempio in caso di furto della chiave privata del server. Esistono delle **Certificate Revocation Lists (CRL)**, ogni CA pubblica una lista dei certificati per cui ha ricevuto una richiesta di revoca dal proprietario, tutti *i client dovrebbero sempre controllare la presenza del certificato nella CRL*. Esiste un *API per richiedere lo stato di un certificato*, si chiama **Online Certificate Status Protocol (OCSP)**.

###### Hardening Public PKI

Passare attraverso una terza parte fidata può portare a problemi, quindi si tende a creare soluzioni ad-hoc come **restrict trusted Cas** (whitelist e blacklist), **HTTP pinning** (relazione hardcoded tra Cas e domini, solo una certa Cas può rilasciare certificati per un dato dominio), **Certificate Transparency** (rendere noti tutti i rilasci dei certificati). Quest'ultima soluzione è semplice: comprende un sistema di ***monitors*** (*monitorano le anomalie*) e ***auditors*** (*verificano la presenza di determinati certificati*). La complessità d'implementazione sta nel fatto che la *lista* contenente i rilasci, una sorta di log con la data di rilascio dei certificati, *diventa a sua volta la terza parte fidata*. L'idea è quella di avere tanti log pubblici.

###### CA Private

Talvolta è utile realizzare una infrastruttura PKI privata per ***comunicazione interne***, con tutti i vantaggi delle PKI (scalabilità, sicurezza). Non c'è bisogno di alcuna fiducia verso terze parti, avendo il *controllo completo ed economicità*. Gli svantaggi di queste soluzioni sono relative alla *gestione complessa*, sono prone agli errori e hanno costi "nascosti" di gestione e infrastruttura.

La sicurezza è una **catena**, una catena è robusta quanto il suo anello più debole, il sistema di Certification Authority ha molti anelli, alcuni dei quali coinvolgono il fattore umano.

## Protocolli Sicuri

I *protocolli più utilizzati per i servizi di rete* utilizzano *TCP* a livello trasporto e IP a livello rete, entrambi risalgono agli anni 80. Sono ottimi protocolli ma non sono stati implementati con la sicurezza a mente. Principalmente affrontiamo 3 problemi:

1. Confidenzialità
2. Integrità
3. Autenticità

Reinventare lo stack TCP/IP sarebbe improponibile, quindi è deciso di ***mantenere i protocolli attualmente in uso*** e ***costruire intorno ad essi una architettura che ne garantisca la sicurezza***. Principali protocolli per la sicurezza: IPsec (livello 3), SSL/TLS (livello 4), HTTPS SSH PGP S/MIME (livello 5). Come possiamo fare a "creare" un *livello intermedio*? Bisogna **creare un nuovo header** servendosi del **tunneling**.

> Tunneling
>
> Incapsulare pacchetti in altri pacchetti: un pacchetto da trasmettere diventa il payload (parte dati) di un altro pacchetto, che viene trasmesso.

### IPsec

Fornendo un layer di sicurezza a livello di protocollo IP (centrale per lo stack TCP/IP) è possibile garantire ***sicurezza*** a tutti i ***protocolli e applicazioni di livello più alto***. Mediante IPsec è possibile avere garanzie di sicurezza diverse tra loro.

- **Authentication Header (AH)** : fornisce *autenticazione della sorgente* e *integrità dei dati*.
- **Encapsulation Security Payload (ESP)** : aggiunge la *riservatezza* (crittografia) del messaggio, che *non viene più mandato in chiaro*. Utilizzabile con AH.
- **Security Association (SA)** : aggiunge il *concetto di sessione al di sotto del livello di trasporto*. Quando viene stabilita una connessione tra endpoint questi *si accordano* se utilizzare *AH* e *ESP*.

IPsec non è solo un'estensione del protocollo IP, è un'architettura di sicurezza completa per il traffico a livello IP, è un insieme di estensioni al protocollo IP per fornire servizi di sicurezza a livello network IP. Inizialmente è stato progettato per IPv6 poi è stato portato anche a IPv4. Le componenti fondamentali di IPsec sono:

1. Security Associations (SA): creazione e gestione di SA
2. Security Protocols: Integrità e autenticazione (AH) e riservatezza (ESP)
3. Internet Key Exchange (IKE): gestione delle chiavi simmetriche

#### Security Association

Accordo tra due entità per stabilire come trasmettere informazioni in modo sicuro. IPsec ha l'obiettivo di supportare vari standard (protocolli di comunicazione, algoritmi di cifratura, ...). Questo porta ad avere una serie di parametri di sessione, che devono essere negoziati prima che la comunicazione abbia luogo. Un host può avere *diverse connessioni IPsec attive* in contemporanea, dove ognuna è determinata univocamente da un *SA identifier*. Le SA sono unidirezionali, quindi per scambiarsi datagram sicuri, due host devono instaurare due connessioni logiche. Dentro alla security association troviamo:

- Un identificatore relativo al protocollo di sicurezza adottato: AH o ESP
- Indirizzo IP della sorgente (ricorda che la SA è unidirezionale)
- Identificatore a 32 bit della connessione che contiene i security parameter index (SPI)

Tutte le security association sono messe in un DB **security policy database (SPD)**, questo db inoltre contiene le security policy da applicare ai diversi tipi di comunicazione. Può essere configurato manualmente o collegato ad un sistema automatico. Il **Security Association Database (SAD)** invece è l'elenco delle SA attive e delle relativi caratteristiche (algoritmi parametri chiavi...)

Ci sono due modalità per realizzare una connessione IPsec: **transport** e **tunnel** mode.

|IPSec Mode|Pro|Contro|
|---|---|---|
|Transport: comunicazione IPSec end-to-end, utilizzata dagli endpoint, non dai gateway|Unica soluzione possibile qualora sia necessario identificare e differenziare i nodi in base al loro indirizzo IP|Ogni host che vuole comunicare deve avere tutto il software necessario ad implementare IPSec facendo aumentare la complessità di gestione quando ci sono tanti nodi comunicanti|
|Tunnel: collega due gateway, in modo ad esempio di far comunicare due LAN tramite internet in maniera sicura senza dover configurare ogni singola macchina della LAN|Nel percorso tra i gateway è impossibile risalire agli IP della sorgente e della destinazione reali, solo i gateway devono avere il software IPSec quindi la complessità rimane bassa anche con tanti hosts| È impossibile differenziare i nodi in base all'IP e la soluzione risulta computazionalmente onerosa (i gateway devono essere "potenti") |

##### Protocollo AH

AH fornisce meccanismi per *autenticare la sorgente* e *controllare l'integrità dell'intero datagram IP*, ad eccezione dei campi variabili dell'header, **non** garantisce la riservatezza dei dati trasmessi. Sostanzialmente i dati vengono spostati dentro un nuovo payload e si aggiunge un header al datagram tra quello di IP e di TCP.

##### Protocollo ESP

ESP permette di garantire la riservatezza nella prima versione cifrando il payload del pacchetto IP, nella seconda versione è in grado di fornire anche autenticazione. È possibile cifrare, oltre al payload, anche l'header. L'header contiene un *Security Parameters Index* (*SPI*), per far sì che chi riceve il pacchetto sappia come decifrarlo.

#### Scambio delle Chiavi

IPsec utilizza chiavi simmetriche, bisogna creare un meccanismo per lo scambio sicuro delle chiavi, in modo automatico e scalabile. Il protocollo di default per la gestione delle chiavi in IPsec è il protocollo IKE (Internet Key Exchange), il protocollo ISAKMP (Internet Security Association and Key Management Protocol) stabilisce le procedure e il formato dei pacchetti per lo scambio delle chiavi. È progettato per essere "key exchange independent", cioè per supportare diversi metodi di scambio delle chiavi. È utilizzato da IKE.

IKE si basa su due fasi:
1. IKE Phase 1
    - Autenticazione dell'utente remoto che vuole iniziare una sessione IPsec
    - Scambio delle chiavi di sessione
2. IKE Phase 2
    - Negoziazione dei parametri della SA IPsec

La prima fase ha due possibili metodi, per crittografia simmetrica e asimmetrica:

1. **Pre-Shared Key** (semplice e veloce): utilizzabile con host che non hanno IP fisso, e che non fa parte delle informazioni necessarie per l'autenticazione. La sicurezza si basa sulle politiche di gestione delle chiavi.
2. **Certificato Digitale** (più sicuro): utilizzabile solo se ogni host connesso ha un IP fisso. L certificazione viene rilasciata da una CA. 

Nella seconda fase i due nodi utilizzano la **ISAKMP** per negoziare la SA per altri protocolli (ad esempio IPSec). Ogni SA fa riferimento ad un canale unidirezionale, una SA è univocamente determinata da:

- Protocollo di sicurezza (AH e/o ESP)
- Indirizzo IP sorgente
- Connection ID (32-bit)

#### IPsec - Sintesi

**Vantaggi**
- Non richiede modifiche hw e sw dei dispositivi di rete
- Rende sicure le comunicazioni a livello network, di conseguenza tutti i protocolli e le applicazioni che utilizzano IP beneficiano di un alto livello di sicurezza

**Svantaggi**
- Necessita di modifiche dello stack TCP/IP standard (supportato da tutti gli OS oggi)
- È abbastanza complesso da gestire
- È un protocollo di sicurezza punto-punto, non funziona per reti broadcast

### SSL

Secure Sockets Layer (SSL) è un protocollo aperto e non proprietario, per avere la possibilità di creare "siti web sicuri". Nel 94 viene pubblicata la versione 2.0 nel 96 la 3.0 (ad oggi il protocollo ssl più diffuso). La nuova versione 3.1 è conosciuta anche come Transport Layer Security TLS, standardizzata nel 98. Sebbene SSL sia considerato lo strumento per la sicurezza del web può essere utilizzato da vari protocolli quali IMAP, POP, SMTP. SSL è un protocollo indipendente dalla piattaforma, opera tra il livello applicativo e quello di trasporto. Garantisce ***riservatezza*** (tramite chiave simmetrica segreta e crittografia simmetrica), ***autenticazione*** (certificazione sia del client sia del server a chiave pubblica) e ***integrità*** (garantita mediante un Message Authentication Code MAC).

SSL è composto da **2 fasi**:

1. **SSL Handshake**: il protocollo di handshake è usato per iniziare le sessioni con autenticazione client-server, uso di cifratura a chiave asimmetrica e verifica mediante certificati, negoziazione di un algoritmo di cifratura e delle chiavi relative, infine lo scambio della chiave master. Permette di controllare i parametri relativi al meccanismo di sicurezza.

   L'obiettivo di questa fase è consentire al server di autenticarsi al client usando una tecnica a chiave pubblica e permettere, sia al client sia al server, di cooperare per la creazione delle chiavi simmetriche usate per cifrare e decifrare velocemente.

   - Autenticazione del server SSL: Un browser dotato di SSL mantiene un elenco di CA affidabile con le relative chiavi pubbliche, quando il browser interagisce con un server web SSL-enhanced, ottiene da questi un certificato (la *chain*) che contiene la chiave pubblica del server, il certificato è rilasciato dal server, poi firmato digitalmente da una CA presente nell'elenco delle CA affidabili del client. Questa caratteristica consente al browser di **autenticare** il server prima che l'utente gli trasmetta informazioni riservate.
   - Autenticazione del client (opzionale): garantisce il server sull'identità dei client (es. banca con i suoi clienti). Anche in questo caso si fa uso dei certificati.

   Fase di Handshake nella *versione 1.3* di SSL:
   ```
         ---     client hello      ---\
   1.  C ---supported cipher suites--- > S
         ---       Key share       ---/

        /---     Server Hello      ---
   2. C< ---key agreement protocol ---
        \---       Key share       ---
         ---    server finished    ---

         ---  checks  certificate  ---\
   3.  C ---     generates keys    --- > S
         ---    client finished    ---/
   ```
   In questa versione si decide di supportare molti meno algoritmi di crittografia, riducendo di molto il numero di combinazioni possibili. Una volta completata la fase di handshke, il layer SSL record si proccupa di trasmettere i dati cifrati mediante l'algoritmo simmetrico e la relativa chiave che client e server hanno concordato.

2. **SSL record**: questo protocollo provvede a trasferire i dati cifrati mediante la chiave simmetrica di sessione. Fornisce i servizi di sicurezza di base secondo le modalità concordate nella fase precedente. Dal lato trasmittente SSL riceve i dati dal livello applicativo (es. http), li cifra e li indirizza a un socket TCP. Dal lato ricevente, l'host legge i messaggi dalla socket TCP, decifra i dati e li indirizza al livello applicativo. SSL record è interfacciato su un protocollo di trasporto affidabile come il TCP. I blocchi creati dal protocollo SSL record sono organizzati in record SSL plaintext. Oltre a **autenticazione** del *server* e **riservatezza** del *messaggio*, il canale di comunicazione garantisce **integrità** del *messaggio*, tramite una funzione hash sicura per creare il MAC (Message Authentication Code). All'arrivo del messaggio+MAC cifrato, il destinatario decifra il MAC, e il messaggio con la chiave simmetrica, eventualmente decomprime, e riassembla il messaggio, calcola il digest e lo confronta con il digest del messaggio ricevuto e se sono uguali, il messaggio può ritenersi integro e viene consegnato al processo applicativo al livello superiore.

## Servizi Applicativi Sicuri

Ora vediamo come tutte le diverse tecnologie viste fino ad ora vengono applicate per lo sviluppo di servizi sicuri.

### Web - https

https (Hyper-Text Transfer Protocol over Secure Socket Layer) è un *protocollo integrato nei browser*, che tramite *SSL* permette l'*autenticazione del server e la cifratura delle comunicazioni*. Per accedere a un servizio https-ssl in forma cifrata è sufficiente indicare il protocollo https con `https://`. http e https sono protocolli diversi e usano porte diverse (80 e 443) è possibile, per lo *stesso server Web*, offrire sia informazioni su *canale non sicuro* sia informazioni su *canale sicuro*. Questa pratica è *sconsigliata* per eventuali problemi di ***SSLstrip***, dove un *attaccante intercetta le risposte dal server* e *fornisce i link https come http*. Chiaramente anche i client web devono supportare il protocollo SSL. Lato server serve un certificato X509, emesso da una CA riconosciuta, se nella sua catena di verifica non c'è una CA di fiducia del client, la sessione può essere cifrata, ma il server non è autenticato (e il client viene notificato). A **differenza** di http, https è un protocollo **stateful**, sia il client sia il server devono tenere traccia delle chiavi private per garantire continuità nella comunicazione per **tutta la sessione**, a livello http, il concetto di sessione si emula con *cookie*. SSL è molto più oneroso di TCP a causa della fase di handshake, di esigenze di CPU sia lato client che server, maggiore traffico, ecc... Ogni browser contiene al suo interno un certificato di default https, in mancanza del caricamento di uno specifico certificato personale relativo all'utente/client, il protocollo https ***non garantisce*** autenticazione dell'utente. L'autenticazione è tipicamente effettuata mediante login/pw a livello applicativo. Una volta creata la connessione sicura la comunicazione è protetta da IP spoofing e masquerading, perché le informazioni non sono leggibili senza le chiavi private. Una chiave privata potrebbe essere violata, ma cambiando ad ogni sessione è difficile che succeda. Le chiavi pubbliche possono essere violate se non sono sufficientemente lunghe. Con le tecnologie odierne una chiave pubblica deve essere di almeno 2048 bit. https **rende sicura la sessione** ma **non dà garanzie sulla sicurezza dei dati**: se il server viene violato è possibile qualsiasi tipo di azione maliziosa.

### Mail - smtp

Standard per trasmissione di email: ***consente lo scambio di messaggi tra client-server*** ed è accompagnato tipicamente da un altro protocollo *IMAP* o *POP* per scaricarli. Il protocollo smtp è *in chiaro e non richiede autenticazione*. Questo comporta vari problemi: interagendo direttamente con un server SMTP è possibile inviare messaggi con mittenti falsi, inoltre esistono *server anonymizer* che hanno il compito di ricevere e inoltrare un messaggio di posta elettronica in modo tale che dal messaggio sia impossibile risalire al mittente originale. I requisiti per la posta elettronica sono **confidenzialità, autenticazione e integrità**; opzionalmente abbiamo anche non ripudiabilità, garanzia di invio/ricezione, e anonimato. SMTP è nato per ***trasmettere messaggi testuali***, supporta solo *caratteri ASCII a 7 bit*, la *crittografia* si basa su *scambi di messaggi binari* quindi abbiamo un *problema di incompatibilità*. Ci sono 2 soluzioni in questo caso: S/MIME e PGP/GPG. Entrambe hanno funzionalità molto simili, la differenza più importante è che S/MIME si basa su Certification Authority per la distribuzione e la certificazione delle chiavi pubbliche mentre PGP si basa su concetto di Web of Trust.

#### S/MIME

S/MIME sta per Secure MIME (Multipurpose Internet Mail Extensions), quindi dobbiamo prima introdurre cos'è il MIME. SMTP può trasmettere solo messaggi testuali, con il tempo è emersa la necessità di uno standard per trasmettere allegati non testuali in grado di trasformare dati arbitrari in caratteri ASCII a 7bit (tipo base64) e gestire la presenza di tali dati all'interno di un qualsiasi messaggio di posta elettronica. Questo standard è MIME. S/MIME viene proposto da RSA Data Security Inc. nel 1995, attualmente è distribuito nella versione 3.2. Si basa su specifiche dello standard della RSA per il formato dei dati e principi di crittografia asimmetrica e su standard X.509 per il formato e la gestione ei certificati digitali. MIME introduce 5 nuovi header:

1. MIME-Version
2. Content-type (7 tipi principali, 15 sottotipi)
3. Content-Transfer-Encoding (come è codificato)
4. Content-ID (come si chiama, opzionale)
5. Content-Description (cos'è, opzionale)

S/MIME offre una modalità consistente per inviare e ricevere dati MIME sicuri. Si basa sullo standard MIME e garantisce *autenticazione, integrità del messaggio, non ripudio e sicurezza del dato e della privacy*. Per fare tutto questo **introduce nuove combinazioni `Content-type/Subtype`**, le più utilizzate sono:

- `application/pkcs7-mime; smime-type=enveloped-data;`: utilizzato per trasmettere dati cifrati
- `application/pkcs7-mime; smime-type=signed-data;`: utilizzato per trasmettere dati firmati digitalmente (integrità e non ripudio ma non riservatezza)
- `multipart/signed;`: permette di firmare messaggi trasmessi in chiaro

S/MIME può essere applicato a qualunque entità MIME creando un'entità MIME con uno dei nuovi tre Content-type. È supportato da qualsiasi client di posta elettronica, anche se non molto utilizzato. Per validare le chiavi pubbliche S/MIME usa i certificati X.509: ogni utente deve possedere un certificato, rilasciato da una CA pubblica o in-house. I due maggiori **ostacoli** alla diffusione di questo protocollo sono stati la diffusione delle **web mail** (il server vede il messaggio in chiaro) e il fatto che la cifratura impedisce l'analisi **antimalware**.

#### PGP

Pretty Good Privacy è un programma di crittografia a chiave asimmetrica ideato da Philip Zimmermann verso fine anni '80 (prima versione nel 91) diventa **standard de facto** per la crittografia della mail e non solo. L'idea di Zimmermann era di rendere la crittografia asimmetrica accessibile a tutti anche da pc, ai tempi per cifrare/decifrare un messaggio mediante RSA sarebbero serviti **minuti**. L'idea di fondo del PGP è **usare la crittografia asimmetrica solo per cifrare e scambiarsi la chiave simmetrica**. Non utilizza MIME (è precedente): *prende il messaggio nella sua interezza*.

##### Funzionamento

Ad esempio:

- Alice cifra il messaggio con la propria chiave simmetrica
- Alice recupera la chiave pubblica di Bob, e con questa cifra la propria chiave
- Alice spedisce a Bob il messaggio cifrato con la propria chiave e la chiave cifrata con la chiave di Bob

PGP, più nel dettaglio:

1. Applica un algoritmo di hashing per generare l'hash del messaggio. Il digest è firmato con la chiave asimmetrica privata (RSA) del mittente per ottenere la firma. Messaggio plaintext e firma vengono concatenati
2. Applica l'algoritmo di compressione ZIP per comprimere l'insieme de messaggio e della firma digitale
3. Genera una chiave simmetrica di 128bit "random"
4. Applica un algoritmo di cifratura simmetrica (prima IDEA) per codificare il messaggio usando come chiave ("session key") il numero casuale generato in precedenza
5. Cifrare la chiave simmetrica IDEA (usata come session key) con la chiave pubblica del destinatario
6. Applica l'algoritmo ASCII Armor Radix-64 per trasformare il messaggio in una serie di caratteri ASCII "bassi". Ciascun gruppo di 3 byte è convertito in un gruppo di 4.

Il destinatario dovrà eseguire a ritroso i passi sopra esposti per decifrare il messaggio. In questo protocollo **manca il concetto di certificazione digitale**.

##### La storia

Nel 91 Zemmermann era pronto per commercializzare il suo software ma c'erano due problemi da risolvere:

1. L'algoritmo RSA era coperto da brevetto
2. La legge anticrimine del 91 stabiliva che le comunicazioni elettronice dovevano permettere al governo (con le necessarie autorizzazioni legali) di essere visionate in chiaro.

Invece di commercializzarlo lo fece pubblicare su Usenet e bullettin board a disposizione di tutti e viene **incriminato** per violazione di copyright da parte di RSA, come trafficante di armi per esportazione illegale di materiale bellico (PGP viene equiparato a missili, mortai e mitragliatrici) dopo 3 anni di guai giudiziari, nel 96, l'FBI rinuncio' all'incriminazione perché il software era ormai diffuso e vi erano molti gruppi di opinione pro Zimmermann. Per migliaia di anni la crittografia è stata rilevante solo per stati e militari, ma oggi serve a tutti per proteggere le transazioni economiche e per garantirsi privacy. La crittografia diffusa a tutti ha il suo *lato oscuro*: protegge le comunicazioni dei cittadini rispettori delle leggi ma protegge anche le comunicazioni di criminali e terroristi.

#### GPG

Gnu Privacy Guard (GPG) è un'*implementazione open source del software PGP*. È stato scelto dalla comunità Linux, poiché non usa l'algoritmo brevettato IDEA, ma **utilizza algoritmi non protetti di crittografia** e quindi può essere usato senza restrizioni, GPG è compatibile con PGP e offre funzionalità aggiuntive non implementate nella distribuzione ufficiale.

##### Utilizzo

Per firmare dati con la propria chiave, si usa il comando `gpg -s` per avere un risultato leggibile si può usare `gpg --clearsign` per scrivere la firma in un file separato `gpg -b` e alcune opzioni sono `--armor` genera l'output del testo in ASCII (Base 64) e `--encrypt` cifra i dati, può essere abbinato a `--sign`. Riassumendo, per inviare un messaggio cifrato e con chiave digitale, il comando completo sarà

```bash
gpg [-u mitt] [-r dest] [--armor] --sign --encrypt [dati]
gpg [--verify] [dati] # per verificare la firma dopo aver decifrato
```

##### Web of Trust

**Web of Trust** è un principio di sicurezza peer-to-peer che non necessita di una trusted third party quale CA o PKI gerarchica per garantire l'autenticità dell'associazione utente-chiave pubblica.

> Se `F` considera `E` una persona attendibile, e se `E` si fida della firma di `A`, allora anche `F` si può fidare della firma di `A`.

###### Creazione di un Certificato

Un **"certificato di identità"** di ***OpenPGP*** (che include la chiave pubblica e le informazioni sul suo proprietario) può essere **firmato elettronicamente da altri utenti**, che attestano l'effettiva associazione di quella chiave pubblica a quel determinato utente. Questo può essere fatto, ad esempio, in un **key signing party**. Si include anche un ***sistema di voto*** che può essere usato per determinare di quali associazioni [chiave pubblica, utente] un utente si può fidare (a sua scelta). Ad esempio: il certificato viene considerato valido se tre conoscenti parzialmente fidati hanno firmato un certificato, oppure il certificato viene considerato valido se un solo conoscente pienamente fidato l'ha fatto.

###### Scadenza di un Certificato

Inizialmente, i certificati avevano durata illimitata, con il problema che se un utente perdeva la sua chiave privata non c'era possibilità di revoca. Anche i "certificati" PGP e OpenPGP hanno certificati con una data di scadenza che li disabilita dopo un certo periodo, evitando (se usati correttamente) i problemi precedenti.

### Posta Elettronica Certificata - PEC

La **Posta Elettronica Certificata** (PEC) viene introdotta in un DL del 2008, con l'intento di attribuire al messaggio di posta elettronica lo stesso valore di una **raccomandata con ricevuta di ritorno** garantendo *certezza della ricezione*, *non ripudio dell'invio*, *integrità dei contenuti* della comunicazione e possibilità di stabilire data ed ora di consegna. In realtà, la PEC offre molte più garanzie rispetto alla raccomandata A/R cartacea, la PEC è una soluzione introdotta *solo in Italia* e basa il suo funzionamento su un sistema che coinvolge i provider Internet scelti rispettivamente da mittente e destinatario. Il prerequisito indispensabile per scambiarsi messaggi certificati mediante PEC è l*'attivazione di un account presso un provider Internet che fornisca questo servizio*. Rispetto alla PEC, un certificato S/MIME:

- Permette di certificare l'intero contenuto del messaggio che si invia
- Consente di inviare comunicazioni a qualunque tipo di indirizzo e-mail
- È interoperabile con qualunque sistema, garantendo portabilità in tutto il mondo
- Permette la protezione del contenuto del messaggio mediante crittografia

### Secure Shell - SSH

**ssh** è un protocollo utilizzato per l'***accesso remoto a un host***, stabilendo un ***tunnel cifrato*** tra un client SSH ed un server SSH, rimpiazza i protocolli che trasmettono le informazioni in chiaro (telnet, rsh, rlogin, ecc...) facendo utilizzo di protocollo Transport Layer, protocollo User Authentication e protocollo Connection. L'**obiettivo** di ssh è instaurare una **connessione sicura** tra un client e un server **per l'utilizzo di una shell remota** (ma non solo), con il presupposto che i due end system *inizialmente non condividano alcuna informazione*. Le fasi di una sessione di ssh sono:

1.  Instaurazione della connessione tra gli host su cui sono in esecuzioni il client e il server ssh: client e server devono creare un canale di comunicazione "sicuro" prima che cominci l'autenticazione dell'utente (in modo che le sue credenziali non circolino in chiaro sulla rete). Per farlo ci sono due alternative:
   1. I due host hanno una chiave condivisa (impraticabile se non ci sono *informazioni inizialmente condivise tra i due*)
   2. Si usa la crittografia asimmetrica, in particolare con il metodo **Diffie-Hellman**:
2. Autenticazione dell'utente al server
3. Utilizzo della shell
4. Chiusura della connessione

Ogni host ha la sua coppia di host key (pubblica/privata), sono chiavi create al momento dell'installazione del software ssh sull'host e identificano in modo univoco l'host. Non sono protette da alcuna passphrase e l'utilizzo è completamente **trasparente** agli utenti. All'avvio di ogni sessione, prima dell'autenticazione dell'utente presso il server, i due computer si scambiano le proprie chiavi pubbliche di host (**host key**), in seguito gli host calcolano una chiave di sessione simmetrica, questa chiave di sessione viene utilizzata per cifrare tutti i pacchetti seguenti (inclusi quelli per l'autenticazione dell'utente). Una volta che il canale di comunicazione "sicuro" tra due host è stato creato, il server verifica le credenziali dell'utente usando come metodo di autenticazione user/psw oppure la chiave utente (**user key**, normalmente memorizzate in modo cifrato sul disco) più sicuro, ma non sempre disponibile.

## Autenticazione e Autorizzazione

L'**autenticazione** è la possibilità di identificare in modo certo chi accede alle risorse e/o chi invia, manipola, riceve i dati, utilizza i servizi. L'autenticazione è una **prova di identità** che ha un duplice scopo, consente

1. Controllo degli accessi: per **individuare** in modo univoco gli utenti che accedono al sistema e ai servizi.
2. Log degli eventi: per supportare il **non ripudio** degli accessi e delle azioni conseguenti

L'**autorizzazione** è il *conferimento* a un'identità digitale del *diritto ad accedere a specifiche risorse* del sistema *in base al ruolo* ricoperto nell'organizzazione. Servono decisioni *politiche* a monte: l'attribuzione all'utente di determinati diritti di accesso e privilegi nell'uso di una o più risorse del sistema informatico. Quando un utente cambia ruolo e soprattutto quando esce dall'organizzazione occorre modificare/eliminare i diritti che competono a quel ruolo. Serve usare funzionalità di **provisioning** e **deprovisioning**.

### Autenticazione

L'autenticazione è il processo che ***verifica la correttezza di un'identità*** dichiarata. Per esempio, quando un utente si connette a un computer, deve inserire **user** (identificazione) e **password** (autenticazione). Per autenticare un utente si possono utilizzare diversi elementi: ciò che l'utente conosce (password), possiede (badge) o è (impronte digitali), l'**autenticazione a due fattori** è un metodo di identificazione che combina **almeno** due di questi elementi. Il metodo più utilizzato, nonostante esistano metodi molto più sicuri è l'autenticazione tramite username e password, perché ha una bassa complessità e pochi costi. Questo metodo di autenticazione è **semplice** per l'utente, **economico** e non richiede di salvare "segreti" lato client, allo stesso tempo però gli utenti spesso usano cattive password, il metodo di autenticazione è debole, capita che si memorizzino "segreti" lato client e il sistema è basato sulle specifiche del sistema operativo. La robustezza di un sistema di sicurezza basato su password è efficace quanto lo sono i suoi sistemi di **mascheramento** delle password memorizzate e **trasmissione sicura** delle password. Le memorizzazioni **non** robuste sono: testo in chiaro, file cifrato, funzione di hash. Per memorizzare correttamente le password è buona abitudine utilizzare qualcosa di noto e testato (Argon2id, bcrypt, PBKDF2) questi hanno alcuni elementi in comune: utilizzo di funzioni di **hash** (con *più iterazioni*), utilizzo di **salt**. L'aumento di complessità della password *non costituisce una garanzia di sicurezza*, ma aumenta il livello di sicurezza del sistema in quanto *incrementa la difficoltà per violarle*.

#### One-Time Password

Password utilizzabili esclusivamente una volta, dopo l'utilizzo la password è immediatamente invalidata. Questo metodo comparta alcune difficoltà tecniche: sincronizzazione (client e server devono generare la stessa sequenza), generazione di sequenze "robust" di password casuali e problema di distribuzione delle password. Vediamo due algoritmi per OTP: HOTP e TOTP.

##### HOTP

HMAC-based One Time Password Algorithm, si basa su sequenze o contatori per essere agevolmente integrato in SIM, smartcard... È economico in termini di risorse computazionali per implementazione in hardware. Il valore generato deve essere agevolmente inserito dall'utente (4/6 caratteri o cifre). Utilizza una **chiave segreta** di almeno 160 bit, conosciuta sia dal client (che deve generare l'OTP), che dal server e un **contatore**, *aggiornato ad ogni autenticazione* (può causare problemi di sincronizzazione se non utilizzato). I due vengono passati come parametri a una funzione HMAC-SHA-1 per la generazione dell'OTP. Il risultato di 160 bit deve essere "troncato" per mantenere un numero di cifre agevolmente digitabili dall'utente. I parametri quindi sono $K$, la chiave segreta e $C$, il contatore: $HOTP(K,C)=Truncate(HMAC-SHA-1(K,C))$

###### Esempio

Vediamo come calcolare un OTP di lunghezza 6:

```C
int offset    =   hmac_result[19] & 0xf;
int bin_code  =  (hmac_result[offset]       & 0xf) << 24
                | (hmac_result[offset + 1]  & 0xf) << 16
                | (hmac_result[offset + 2]  & 0xf) << 8
                | (hmac_result[offset + 3]  & 0xf);
```

e otteniamo:

```
+-----------------------------------------------------------+
|                     Byte Number                           |
+-----------------------------------------------------------+
|00|01|02|03|04|05|06|07|08|09|10|11|12|13|14|15|16|17|18|19|
+-----------------------------------------------------------+
|                     Byte Value                            |
+-----------------------------------------------------------+
|1f|86|98|69|0e|02|ca|16|61|85|50|ef|7f|19|da|8e|94|5b|55|5a|
-------------------------------***********----------------++|
```

- L'ultimo byte (19) ha il valore esadecimale `0x5a`
- Il valore degli ultimi 4 bit è `0xa` (offset)
- L'offset individua il byte 10 (`0xa`)
- Il valore dei 4 byte a partire dal decimo è `0x50ef7f19`, chiamiamo questo codice Dynamic Binary Code 1 (DBC1)
- Il byte più significativo di DBC1 è `0x50`, quindi `DBC2=DBC1=0x50ef7f19`, `HOTP=DBC2%10^6=872921`
- Si considera il dynamic bynary code come un intero senza segno a 31-bit, con codifica bit; il primo è mascherato con `0x7f`
- Si calcola il modulo `10^6` del numero ottenuto per generare il codice HOTP di 6 cifre decimali.

##### TOTP

Variante di HOTP che considera l'**istante temporale** attuale come parametro al posto di un contatore. Consente di generare OTP con validità limitata nel tempo &rarr; miglioramento della sicurezza rispetto a HOTP, le implementazioni potrebbero utilizzare HMAC-SHA-256 o 512 invece di 1. Il token e il verificatore devono poter conoscere lo unix time corrente, serve **sincronizzare gli orologi**. Infine la chiave dovrebbe essere generata casualmente o derivata mediante appositi algoritmi. I parametri di questo algoritmo sono la chiave $K$, gli istanti temporali $T_0$ (default unix epoch), $T_C$ (delta tra $T_0$ e il tempo attuale) e $T_S$ (step temporale, ogni quanto viene rigenerata la password) e la lunghezza dell'OTP $N$, per generare un OTP quindi: $T_C = \lfloor(unixtime(now)-unixtime(T_0))/T_S\rfloor$ , $TOTP = HOTP(K,T_C)\%10$

Generalmente i servizi TOTP si acquistano da **provider specifici**.

### Autorizzazione

L'autorizzazione è il processo di **verifica** che un soggetto autenticato abbia il ***diritto di effettuare certe operazioni***. L'autorizzazione deve essere *a valle di una robusta autenticazione* e una scelta manageriale di chi può fare cosa (appartenenza a gruppi, ruoli).

#### Autenticazione e Autorizzazione Centralizzata - LDAP

Il sistema centralizzato evita ridondanze, riduce possibili errori, e semplifica la gestione. LDAP (Lightweight Directory Access Protocol) è un protocollo per implementare il servizio di directory service consolidando i servizi esistenti in un singolo indice che può essere acceduto dai client. Qui è possibile trovare tutte le informazioni relative ai propri dipendenti. Riduce il carico amministrativo per A&A e facilita il provisioning e deprovisioning di risorse digitali. Esiste anche in versione free open source OpenLDAP.

#### Kerberos

Protocollo di autenticazione basato sull'uso di **ticket**.

1. Il client contatta l'Authentication Server (AS) per segnalare che l'utente vuole chiedere servizi, e richiede un Ticket Granting Ticket (TGT) o ***ticket master***. Il messaggio inviato non è cifrato. Ogni client condivide con AS una chiave segreta.

2. A questo segue una **fase di autenticazione**, dove AS controlla se il client è registrato nel suo db e in caso affermativo invia al client il TGT.
3. Quando il client vuole accedere a un servizio, il client **fornisce al Server il** **TGT**. 
4. Il **Server dà al client il ticket** che gli permette di accedere allo specifico servizio.

Il funzionamento è *simile a quello di OAuth*, basato su *token*.

#### Microsoft Active Directory

L'utente comunica al server di Active Directory le credenziali. Se valide, il server AD autentica la richiesta e fornisce una coppia di token access/refresh, infine il token è inviato al servizio per l'utilizzo.

### Single Sign On

**Single sign-on (SSO)** è una proprietà del controllo di ***accesso di molteplici sistemi*** software correlati, ma indipendenti. Grazie a questa proprietà un utente ***si autentica una volta sola*** ottenendo l'accesso a tutti i sistemi aziendali senza che gli venga chiesto di introdurre le credenziali in ciascuno di essi.

#### Benefici di SSO

- Riduzione della complessità di gestione di molteplici combinazioni di password da parte dell'utente
- Riduzione del tempo impiegato a inserire el password per la stessa identità
- Riduzione del costo aziendale grazie alla diminuzione del numero delle chiamate all'help desk a causa della password dimenticata
- Possibilità di imporre nell'organizzazione policy unificate per l'autenticazione e l'autorizzazione
- Si evita ai sistemisti di dover implementare un nuovo sistema di controllo degli accessi per ogni nuova applicazione che viene sviluppata o installata

#### Problemi di SSO

- Impatto negativo nel caso in cui le credenziali siano disponibili ad altre  persone e siano utilizzate in modo improprio
- Richiede maggiore attenzione alla protezione delle credenziali, dovrebbe essere combinato con OTP.
- Rende i sistemi di autenticazione critici, il loro errore può comportare la negazione dell'accesso a tutti i sistemi (single point of failure).

### Zero Trust Architecture

La **Zero Trust architecture** è un nuovo *modello di sicurezza* di A&A basato su **Zero Trust**, il nuovo perimetro è identità utente/dispositivo. Questo modello ***elimina il concetto di rete interna trusted*** (fiducia implicita) solo perché interna: tutti i *dispositivi della intranet* aziendale hanno gli *stessi privilegi di un PC esterno collegato da Internet*. Il **perimetro** viene ***spostato sulla singola risorsa***. Applica a ogni risorsa aziendale:

1. Autenticazione *forte* (almeno a due fattori) di tutti gli utenti e di tutti i dispositivi gestiti dall'azienda
2. Autorizzazione mediante regole a grana fine, secondo il least privilege principle
3. Logging di tutte le richieste di autenticazione e autorizzazione negate e concesse

In una zero trust architecture:

1. La **rete** viene sempre considerata **ostile**: dalla rete (interna o esterna) vengono veicolate minacce
2. La **posizione dell'utente** in una certa rete non è sufficiente a definire il suo livello di fiducia
3. Ogni **dispositivo**, utente e richiesta deve essere sempre autenticato e autorizzato
4. È opportuno che tutti gli utenti  utilizzino sistemi di **strong authentication** o autenticazione a più fattori
5. Vi possono essere **politiche** più statiche sulle autorizzazioni degli utenti e degli amministratori di sistema, ma la maggioranza delle policy di A&A devono essere dinamiche e adattive.
6. Serve **monitoraggio** continuo (di anomalie e tentativi di attacco) in quanto non si può avere la garanzia che nella ZTA non vi siano vulnerabilità umane, software o di configurazione.

#### BeyondCorp di Google

Google è stata la prima azienda che ha iniziato a mettere in pratica questo approccio nelle proprie reti sin dal 2012. Oggi il modello Zero Trust di Google è un brand: **BeyondCorp** che è possibile abilitare in qualsiasi organizzazione integrata con google cloud platform. Gli amministratori di sistema possono applicare **controlli di accesso molto granulari** per applicazioni web, macchine virtuali, API e applicazioni della GSuite sulla base di attributi quali identità utente, livello di sicurezza del dispositivo, IP/MAC e altri parametri. I **componenti** di BeyondCorp sono:

- Identificazione del dispositivo e dell'utente
- Device Inventory Service: salva, elabora e pubblica gli aggiornamenti sul livello di attendibilità dei dispositivi
- Gateway: permettono di accedere alle risorse tramite ssh o proxy web. I gateway consentono solo il traffico attraverso tunnel conformi alle politiche stabilite nell'Access Control Engine.
- Access Control Engine: servizio centralizzato di applicazione delle policy, a cui fanno riferimento tutti i gateway che devono prendere una scelta di autorizzazione o meno, sulla base del Trust Inferer.
- Trust inference: annota e analizza continuamente lo stato di ciascun dispositivo, imposta il massimo livello di attendibilità del device e lo salva nel Device Inventory Service.

##### Identificazione dei Dispositivi

Il **Device Inventory Database** tiene *traccia* di ogni *dispositivo che accede alle applicazioni aziendali*, in particolare monitora le modifiche apportate da un certo dispositivo e tutte le sue informazioni sono disponibili agli altri componenti di BeyondCorp. I dispositivi devono essere identificati **univocamente**, a tale scopo viene utilizzato un certificato memorizzato in modo protetto (**device identity**). Un processo convalida il certificato e solo se un dispositivo è ritenuto sicuro è "gestibile dall'azienda". Questo controllo è necessario ma non sufficiente per concedere i permessi di accesso.

##### Funzionamento

1. L'utente effettua una richiesta che viene reindirizzata all'Access Proxy che controlla il certificato del dispositivo
2. L'Access Proxy ridirige il client al sistema di SSO che costituisce il fattore primario di autenticazione delle credenziali.
3. Se si viene autenticati correttamente, viene rilasciato un token temporaneo
4. L'**Access Proxy**, sulla base del certificato del device e del token SSO è in grado di identificare l'utente
5. L'**Access Control Engine** effettua *controlli a ogni richiesta*, ad esempio se l'utente si trova nel gruppo corretto, se l'utente e il dispositivo possiedono un livello di fiducia sufficiente. Se anche solo uno di questo controlli fallisce, la richiesta sarà rifiutata.

##### Controlli per l'accesso

BeyondCorp usa un meccanismo di **Network Access Control** per autenticare i dispositivi che chiedono acceso alla rete (supplicant). Questo protocollo usa un dispositivo di accesso alla rete (Access Point), tipicamente uno switch , che ha il compito di inviare i pacchetti utente al **server RADIUS** (Remote Authentication Dial-In User Service) e viceversa. Il server RADIUS gestisce il servizio di autenticazione delle credenziali e di autorizzazione per l'accesso alla rete. In base allo username presente nel certificato, fornito durante il wifi handshaking, si associa il dispositivo a una specifica VLAN. Tutte le applicazioni sono mediate tramite un proxy che inoltra le richieste a un back-end dopo il superamento dei controlli di accesso sulla base dell'Inventory-Based Access Control.

##### Identificazione

**Database di utenti e gruppi**: così come i device anche gli accessi degli utenti vengono tracciati e aggiornati continuamente specificando i loro ruoli nell'azienda e la loro eventuale appartenenza a gruppi di lavoro. Mediante un sistema di autenticazione a due fattori, anche di tipo SSO, si convalidano le credenziali di primo e di secondo livello necessarie per accedere alle risorse. Il sistema genera un token temporaneo che serve per l'autorizzazione a specifiche risorse.

##### Livello di Fiducia

Si possono avere **diversi livelli di fiducia** assegnati a diversi *utenti* e/o *dispositivi*: queste regole possono essere ***dinamiche***.

##### Problemi di Gestione

La stessa Google non ha migrato tutto e subito su di un'architettura ZTA come BeyondCorp perché avrebbe potuto comportare molti problemi per la normale attività, pertanto ha optato per una **migrazione graduale**:

- È stata costruita la **Traffic Analysis Pipeline**, che prende come input il traffico dati che passa da ogni switch dell’azienda permettendo di elaborare il traffico che non è in transito con BeyondCorp, per poter migliorare in seguito
- Per accedere a una risorsa bisogna avere il livello minimo di affidabilità richiesto per l’accesso: ogni grado di fiducia di ciascun dispositivo è assegnato dal Trust Inference
- Si è partiti da un principio di ZeroTrust e si sono monitorate e verificate tutte le richieste. Quelle ritenute corrette sono state consentite
- Gli utenti e i servizi sono stati spostati sulla ZTA BeyondCorp solo quando si era veramente sicuri che tutto avrebbe funzionato correttamente e non ci sarebbero stati problemi sui flussi di lavoro


## Security Monitoring e Intrusion Detection

### Monitoraggio Continuo

Attività (normali e attacchi) generano **eventi** di vario tipo: rete, sistema, sicurezza... Questi eventi devono essere **visibili** e **collezionabili**. Le **attività normali e le anomalie** (attacchi inclusi) devono essere ***distinguibili tramite algoritmi di analisi***. Il monitoraggio non significa reazione automatica, infatti **permette di rilevare anomalie** e attacchi e abilita reazioni rapide ma *non aumenta (da solo) il livello di sicurezza del sistema monitorato*. Ci sono dei **dispositivi di sicurezza** che possono produrre ***log più rilevanti di altri*** (es. *traffico particolare loggato da un firewall*). In dettaglio il ciclo della **detection** consiste in 4 fasi:

1. Collection: identificazione e filtraggio dei log.
2. Fusion: i log vengono portati in un *sistema automatizzato di analisi*. Automazione tramite ad esempio regole di firewall e **SIEM** (Security Information and Event Management).
3. Analysis: regole predeterminate, triage investigativo e cyber security intelligence.
4. Action: risposta, rimedio e ricovero, investigazione, gestione degli incidenti, report e cambio di gestione.

La **collezione** e la **fusione** sono tipicamente fatte in modo *automatico*. Tutte le tipologie di eventi (rete, sistema, threat intelligence) vengono mandati a un ***sistema di intrusion detection*** che eventualmente genera degli **allarmi di sicurezza**. Questi vengono passati al **SIEM** per essere elaborati e al **Security Operation Center**. Una volta che il SIEM elabora gli allarmi ricevuti, anche questi vengono inviati al SOC.

#### Eventi di Rete

Gli eventi rilevanti in ambito di rete sono catturati mediante diversi metodi, tra cui:

1. **Full Packet Capture**: catturo e memorizzo una *copia dell'intero traffico di rete*.
2. **Network Metadata**: metadati a livello di rete, trasporto applicativo (Deep Packet Inspection)
3. **Netflow**: metadati a livello di rete.

Consentono di rilevare attacchi informatici che causano la ricezione o l'invio di pacchetti.

##### Full Packet Capture

Consiste nella materializzazione del traffico di rete, generato mediante l'utilizzo di software **sniffer**. Lo sniffer acquisisce una copia del traffico di rete (Network TAP o Switch con SPAN port, apposito per l'analisi del traffico).

|**Pro**|**Contro**|
|---|---|
|Consente di effettuare qualunque tipo di analisi del traffico in un tempo successivo alla cattura|Difficile acquisire il traffico su reti ad alta velocità|
|Consente di approfondire le analisi a seguito di allarmi o altri eventi di interesse|Elevati costi di storage, in relazione alla retention desiderata|
|Abilita attività di network forensics post-incidente|Tipicamente utilizzata solo in modo selettivo su specifici flussi di traffico (e.g. pochi indirizzi IP o numeri di porta|

##### Network Metadata

Descrizione sintetica delle ***caratteristiche principali delle comunicazioni di rete***. Possono includere anche il contenuto (integrale o parziale) delle comunicazioni di rete che utilizzano protocolli applicativi supportati. Buon *compromesso* tra complessità di acquisizione, problemi di retention e utilità per l'analisi. Non vengono estratti i pacchetti, ma ***solo metadati***.

##### Netflow

Metadati relativi **solo** ai livelli di **rete** e **trasporto**, nessuna informazione sul contenuto delle comunicazioni. Possono essere generati da molti apparati di rete con basso costo computazionale e bassi requisiti di memorizzazione.

##### Confronto (in *ambito telefonico*)

|**Full Packet Capture**|**Network Metadata**|**Netflow**|
|---|---|---|
|registrazione completa di una telefonata, include l'audio e i metadati principali (numeri di telefono, chi ha chiamato e quando). Richiede molto spazio di storage e tempo per l'analisi.|rapporto di analisi che include i metadati principali (numeri di telefono, chi ha chiamato e quando), altri metadati calcolati (durata chiamata, ...) può anche includere un riassunto della comunicazione in formato strutturato, se l'intercettatore ne conosce la lingua. Richiede poco spazio di storage, può essere utilizzato per analisi automatiche.|Lista delle chiamate con numeri coinvolti, chi ha chiamato chi, quando la chiamata è iniziata, durata della chiamata. Minimi requisiti di storage, retention anche molto lunga, possono essere utilizzati per analisi automatiche.|

#### Eventi di Sistema

In linea di principio, con **evento di sistema** si intende qualunque cosa accada su un dispositivo/apparato di qualunque tipo. Questa definizione risulta molto più *vaga* rispetto agli eventi di rete (pacchetti). Esempi principali sono:

- Log del sistema operativo: avvio/arresto, login/out, errori e problemi di vario tipo
- Log generati da applicazioni: avvio/arresto di applicazioni, attività svolte dall'utente in singole applicazioni
- Log generati da firewall: pacchetti che hanno trovato corrispondenze con alcune regole specifiche
- Log e allarmi generati da sistemi di endpoint protection: eventuali malware rilevati, stato e tempistica delle scansioni, livello di aggiornamento di sistema
- Stato di file/registri di configurazioni
- Sistemi di controllo degli accessi: chi è entrato e quando

Questo tipo di eventi consente di rilevare attacchi che causano eventi di sistema rilevabili quali:

- Privilege escalation che comporta il login di un utente con privilegi elevati
- Tentativi di sfruttamento di vulnerabilità che causa il riavvio del sistema operativo o di un servizio applicativo
- Lo stesso utente che effettua login su multiple macchine
- Malware rilevato dall'endpoint protection

#### Threat Intelligence

Feed di informazioni generate da terze parti, tra cui, **vendor di soluzioni di sicurezza**, **CERT** pubblici e privati e altre realtà aziendali. Tipici esempi sono:

- Liste di indirizzi IP noti per essere stati compromessi, diffondere malware, ecc.. nel recente passato
- Indicator of Compromise (IoC) che contengono i principali artefatti creati da malware o alcune caratteristiche degli attacchi portati via rete (porte e protocolli utilizzati, dettagli di richieste e risposte applicative)
- Procedure Tecnico Tattiche (TTP) di attacchi recenti
- Informazioni relative a campagne di attacco verso specifici settori o brand aziendali
- Informazioni relative a APT e gruppi di attacco

La **threat intelligence** è molto utile quando strutturata e facilmente gestibile/integrabile in strumenti di analisi, in altri casi necessitano un analista (umano). Le *fonti migliori sono a pagamento*.

### Intrusion Detection Systems

Con **intrusione** si intende un insieme di ***azioni tese a compromettere la sicurezza***, cioè l'integrità, riservatezza e/o disponibilità di una risorsa (intesa come rete, sistema o servizio). **Intrusion Detection** è il processo di identificazione delle attività di intrusione, **non include** la **prevenzione** delle intrusioni e le possibili **reazioni** ad attività di intrusione. I sistemi di Intrusion Detection possono essere specifici per gli eventi analizzati, sono necessari per diverse ragioni:

- Per realizzare un meccanismo di protezione multi-livello: prevenire &rarr; rilevare &rarr; reagire/riparare
- Perché gli attacchi non arrivano solo dall'esterno (prevenzione inutile), anzi... **inside threat**
- Perché ***registra attacchi e tentativi*** di attacco. Utile ***per motivi legali*** (computer e network forensics) e per *giustificare il budget speso* per la sicurezza.

I sistemi di intrusion detection assumono che le attività del sistema informatico sono **osservabili** e che le attività normali e quelle intrusive sono **distinguibili**. I componenti di un IDS possono essere visti in una prospettiva **algoritmica** (caratteristiche e modelli di intrusioni) o **sistemistico-architetturale** (analizzatori di dati, generatori di allarmi ed eventuali risposte).

#### Funzionalità base

Le funzionalità base di un IDS sono:

- Analisi del traffico di rete, dei log di sistema e di altri eventi
- Rilevamento delle attività sospette e/o illegali mediante ***algoritmi di intrusion detection***
- Allerta dei responsabili della sicurezza, ***generazione di allarmi***
- Logging dettagliato delle attività rilevate

La parte di ***reazione agli allarmi*** viene lasciata agli operatori. Alcuni sistemi possono applicare delle ***contromisure in modo automatico***. In questi casi si parla di sistemi di **intrusion prevention**.

**falsi positivi** e **falsi negativi** rappresentano i principali **problemi** di un IDS. L'**accuratezza** e **completezza** di un IDS sono i principali indicatori di prestazioni (difficile che un sistema sia entrambi):

- **Sistema ACCURATO** &rarr; *non genera **falsi positivi***. Intrusione sicura.
- **Sistema COMPLETO** &rarr; *non genera **falsi negativi***. Tutti gli attacchi vengono riconosciuti.

#### Valutazione Algoritmica

Dati un allarme $A$ e un intrusione $I$ definiamo le seguenti probabilita:

- Veri positivi $P(A|I)$&rarr; allarme per una reale intrusione
- Falsi negativi: $P(\neg A|I)$&rarr; nessun allarme per una reale intrusione
- Falsi positivi: $P(A|\neg I)$ &rarr; allarme per nessuna intrusione
- Veri negativi: $P(\neg A|\neg I)$ &rarr; nessun allarme per nessuna intrusione
- Detection Bayesiana: $P(I|A)= \frac{P(I)P(A|I)}{P(I)P(A|I)+P(\neg I)P(A|\neg I)}$ 

#### Valutazione Sistemistica

I fattori da tenere in considerazione in questo tipo di valutazione sono **alte prestazioni**, **scalabilità** e **elevata resistenza agli attacchi**.

#### Metodi di Rilevamento

Gli IDS si distinguono in base alla **logica utilizzata** per *identificare le intrusioni*. Si tratta di *due approcci opposti*:

- *Sistemi basati su **firme*** &rarr; assumendo di *conoscere tutti gli attacchi informatici*, è possibile riconoscerli mediante dei **pattern** (firme). (es. `src_ip == dst_ip`, byte in determinate posizioni). Permette di *riconoscere la tipologia di attacco*. Gli eventi non riconosciuti si assumono come buoni.
  - ***pro***: semplice implementazione, applicabile a diversi protocolli.
  - ***contro***: se la firma è fatta male, genera falsi positivi. Se la firma è conosciuta dall'attaccante, può darsi che quest'ultimo cerchi di crearne una variante. Il database di pattern richiede un aggiornamento costante.
- *Sistemi basati su **anomalie*** &rarr; non si ha conoscenza degli attacchi informatici, ma *si conosce il sistema che si vuole proteggere*. Il sistema deve seguire un certo **modello di comportamento accurato**. Si assume che un attacco informatico genera una deviazione (anomalia) dal comportamento normale del sistema.
  - ***pro***: permette di individuare attacchi sconosciuti. L'overhead del sistema è minimo (alto solo durante la fase di creazione del modello di comportamento)
  - ***contro***: scarsa accuratezza anche nel caso di attacchi conosciuti che però non generano anomalie (*alto tasso di falsi positivi*). Difficoltà iniziale nella creazione del modello

Un IDS lavora in modalità **stateless** quando si limita ad *analizzare il singolo pacchetto*, **stateful** quando è in grado di *analizzare il flusso di pacchetti appartenente alla stessa connessione*. L'**analisi** si dice **passiva** quando l'IDS *cattura una copia dei pacchetti e si limita ad analizzarli*, **attiva** quando gli IDS *sono in grado di prendere provvedimenti* (Intrusion Prevention Systems, IPS).

#### Localizzazione della Funzione di Analisi

- Livello **Host** (**HIDS**): la funzione di IDS è posta *su un singolo host* (o *segmento di rete*). Tipicamente analizzano *eventi di sistema*.
- Livello **Network** (**NIDS**): si tratta di un *IDS distribuito* (reti di grandi dimensioni dove sono necessari più IDS). Tipicamente analizzano *eventi di rete* e vengono collegati alla *span port* di uno switch (su cui si inoltra una copia del traffico). Non può interrompere il traffico come il *firewall*. Se si vuole essere in grado di *bloccare il traffico* si deve passare a una nuova configurazione in cui all'IDS arriva l'intero traffico di rete (non una copia!) e si parla di **NIPS**, in grado di *prevenire un'intrusione* (es. IPS sulla *rete locale*, IDS sulla *DMZ*).
  - **pro**: hanno *visibilità di tutta la rete* che si vuole proteggere
  - **contro**: *incapace di analizzare il traffico cifrato*

> **Insertion Attacks**
>
> Attacco fatto a un NIDS. L'attaccante genera una sequenza di pacchetti `T-X-T-C-A-A-K`, dove `X` è un pacchetto con un checksum errato. Questo viene preso in considerazione e ricostruito dal NIDS, che però non controllando il checksum ricostruisce `A-T-X-T-A-C-K`, non riconoscendo la signature `A-T-T-A-C-K` e lasciando che questo arrivi all'end system. L'OS dell'end system controlla il checksum e ricostruisce correttamente il pacchetto `A-T-T-A-C-K` e viene quindi attaccato.

## VPN - Virtual Private Network

Realizzare un rete privata virtuale utilizzando connessioni e apparati di trasmissione pubblici (Internet). Per sostituire i collegamenti fisici (via cavo) chiaramente illogici per grandi distanze, nasce **IP-VPN**. Questo protocollo separa il traffico a livello $\leq network$. IP-VPN è un **overlay network** su una rete IP esistente. Utilizza tunneling e/o incapsulamento a livello di protocolli.

- Risparmio
- Diffusione
- Scalabilità

Una VPN può essere utilizzata per creare collegamenti end-to-end tra due host appartenenti a due sottoreti diverse passando per internet.   Può permettere a un router di **comunicare in modo cifrato** (tunnel IPsec, SSL, TLS) con un **endpoint di una rete geograficamente distante**. Ancora meglio per mettere in comunicazione due intere sottoreti tramite dei vpn gateway. O infine per permettere ad un singolo client di collegarsi al vpn gateway quando in remoto. Può essere implementata sia tramite IPsec che con SSL/TLS, il primo introduce meno overhead quindi risulta più efficiente, il secondo meno performante ma più flessibile.

