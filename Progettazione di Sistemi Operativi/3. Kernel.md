# 3.1 Punto di Vista INTERNO

## 3.1.1 Sistema Operativo

`NUCLEO` &rarr; ***primo livello di astrazione*** del Sistema Operativo

Il nucleo dovrebbe, per quanto possibile, *contenere solo meccanismi* consentendo a livello dei processi di utilizzare tali meccanismi *per la realizzazione di politiche di gestione*, diverse a seconda del tipo di applicazione.

# 3.2 Progettazione del Nucleo di un Sistema Operativo Multiprogrammato

**Ipotesi**: Architettura Monoprocessore

Il nucleo deve fornire il *supporto* per:

1. Processi Sequenziali che possono essere in vari stati:
   - 1 Processo in Esecuzione (perché monoprocessore) &rarr; *RUNNING*
   - In una coda di processi pronti &rarr; *READY QUEUE*. Il loro stato di esecuzione viene salvato in un *Descrittore di Processo* e sono mandati in esecuzione attraverso specifici *ALGORITMI DI SCHEDULING*.
   
2. Meccanismi di Sincronizzazione, avendo prima definito il *modello di riferimento*:
   - Modello ad Ambiente Globale
     - *SEMAFORI* con *coda dei processi sospesi*
     - *OPERAZIONI* sui semafori (*Inizializzazione*, *WAIT* e *SIGNAL*)
   - Modello ad Ambiente Locale
     - *CANALI DI COMUNICAZIONE* con *coda dei processi sospesi*
     - *OPERAZIONI* (*SEND* e *RECEIVE*)
   
   In entrambi i casi le operazioni di sincronizzazione (sia sui semafori che sui canali) sono *PRIMITIVE*. Ogni volta che un processo esegue una di queste operazioni si transita da:

<center><b><i>STATO UTENTE &larr;&rarr; STATO SUPERVISORE (SISTEMA)</i></b></center>

La *visione complessiva* che deve avere il nucleo è quella dello ***stato globale del sistema***, ovvero lo stato di tutti i processi e, nel caso del modello ad Ambiente Globale, di tutte le risorse (occupate/disponibili).

# 3.3 Progettazione delle Strutture Dati del Nucleo

1. **Registro che identifica il *processo in esecuzione*** (RUNNING). Il processo running *può essere o meno mantenuto nella*
   *coda dei processi pronti*. Il registro non è necessariamente hardware.

2. Un ***DESCRITTORE* per ogni processo**  &rarr; **Process Control Block (*PCB*)**
3. Una ***coda dei processi pronti*** (*READY QUEUE*), a livello logico. A livello implementativo possono esserci più code.
4. Una ***coda dei processi sospesi*** (possono anche essere più code)
   - *code eventi esterni*
   - *code semafori* (in *Ambiente Globale*)
   - *code canali* (in *Ambiente Locale*)

Le code, sia quella dei processi pronti che quelle dei processi sospesi, possono essere gestite in *modalità FIFO*. Se a livello di progetto, si associa una *PRIORITÀ ai processi* che influenza l’algoritmo di scheduling, queste possono essere gestite tramite essa.

Bisogna quindi decidere se la READY QUEUE è:

- Realizzata con *una sola coda con i descrittori accodati in ordine di priorità* &rarr; nel momento in cui un processo può essere messo in stato di *READY*, deve essere messo in coda nella posizione corrispondente al suo *grado di priorità*, cosa non semplice.
- Se è realizzata *con più code di descrittori* &rarr; *una per ogni priorità*

Oltre che stabilire il *range di valori* che può assumere la priorità e se un valore basso significa priorità alta o bassa, è bene distinguere tra priorità:
* statica
* dinamica 

## 3.3.1 Descrittore di Processo

Un descrittore di processo deve riportare le seguenti informazioni:

- **Nome** del processo, solitamente un *numero identificativo* (*PID*) per identificare univocamente un descrittore.

- **Stato** del processo; in una ipotesi di minima:
- pronto
- bloccato
- in esecuzione (solo se il PCB resta nella coda di processi pronti, altrimenti basta un riferimento *RUNNING* nel registro).
- **PROGRAM COUNTER** &rarr; indirizzo della prossima istruzione da eseguire. Serve per quando il processo riprende la propria esecuzione dallo stato di *pronto* o *bloccato*.
- **Registri della CPU** &rarr; serve sempre quando un processo riprende la propria esecuzione. Serve per riprendere l'esecuzione in modo corretto. A seconda dell'hardware sottostante si possono trovare le seguenti tipologie di registri:
- accumulatori
- registri indice
- registri generali
- **Informazioni di Scheduling**:
- priorità
- puntatore al prossimo processo in coda &rarr; se la lista presenta un solo elemento al puntatore sarà assegnato il valore *NULL*.
- **Informazioni di Accounting**
- tempo di CPU usato
- limiti di tempo (correlati agli algoritmi di scheduling in *time sharing*)
- **Informazioni sullo Stato di I/O**
- richieste non soddisfatte di I/O
- dispositivi assegnati
- lista file aperti
- **Informazioni per la Gestione della Memoria**

Nel momento in cui un processo viene creato nel S.O (e quindi si lancia un programma in esecuzione), deve essere creato il suo descrittore. A livello progettuale si hanno due scelte.

1. Quando ho *necessità di avere un nuovo processo attivo nel sistema* si crea anche una memoria (*struttura dati*), come quella appena specificata nell'elenco soprastante. Il tempo che il sistema impiega ad allocare questa memoria viene denominato ***tempo di overhead***. In questo caso, dopo la creazione del processo, è necessario un tempo supplementare per *creare il descrittore di processo*.
2. Allocazione di una ***Pool di Descrittori Liberi***. Il nucleo in questo modo mantiene una coda di *descrittori disponibili* per non perdere in seguito del tempo ad allocarli. Questi descrittori vengono mano a mano associati ai processi creati e tornano disponibili alla loro distruzione. Nel caso non ci siano descrittori disponibili, il nucleo può segnalare un errore all'utente (UNIX/LINUX) oppure allocarne uno nuovo.

### Esempi di Descrittori di Processi

#### In UNIX

Il *descrittore esiste per tutta la vita del processo* e contiene tutte le informazioni importanti per il processo (sia quando è in esecuzione e sia quando è pronto o sospeso).

- **pid** (process identifier) &rarr; nome del processo

- **ppid** (parent process identifier) &rarr; nome del processo padre
- **real uid** (user identifier)
- **real gid** (group identifier)

Un processo è creato da un utente (con un UID e un GID) di cui si tiene traccia nel descrittore.

- **effective uid** (user identifier)
- **effective gid** (group identifier)

Un processo può eseguire un programma che ha il SUID e/o il SGID settato che appartiene ad un utente (con UID e GID) di cui si tiene traccia nel descrittore.

- locazioni delle aree utente e di kernel &rarr; rappresentano le *Informazioni per la Gestione della Memoria*. Lo spazio di indirizzamento in UNIX è diviso in un'area utente e un'area di codice.
- **stato** del processo
- **priorità** del processo
- **puntatore al prossimo processo in coda**

#### In LINUX

Linux usa due termini diversi a seconda del punto di vista:
a) **Punto di vista del KERNEL** &rarr; *task = entità con dati e codice*
b) **Punto di vista ESTERNO** &rarr; *processo = parte dei task eseguita in user mode*

Per quanto risulta dal codice scritto in C per la versione del *Kernel 2.0* abbiamo:

- Tabella dei Processi (statica), corrispondente al Pool a cui si è fatto riferimento precedentemente
- Stato del Processo
- Identificatore del Processo
- User ID, Effective User ID, Saved User ID
- Group ID, Effective Group ID, Saved Group ID
- Tempo di Esecuzione
- Priorità Statica
- Codice di Terminazione
- Task *Seguente* e Task *Precedente*
- Padre Originale
- Padre Attuale
- Informazioni sui File Aperti

# 3.4 Progettazione delle Operazioni del Nucleo

Queste operazioni sono rappresentano le ***chiamate di sistema (system calls)*** o ***primitive***, che *funzionano sempre in STATO SUPERVISORE*. Prendendo come riferimento un *processo UNIX*, questo può eseguire in due modi diversi:
* "processo di utente" (***user mode***) &rarr; modo di esecuzione *NORMALE*
* "processo di sistema" (***kernel mode***) &rarr; modo di esecuzione con *MAGGIORE VISIBILITÀ*

La transizione tra i "*modi*" user e kernel avviene *mediante l'invocazione delle primitive*. L’esecuzione delle primitive avviene in ***stato kernel*** con una *visibilità maggiore*, in quanto devono andare ad agire su strutture dati non accessibili in *user mode*.

## 3.4.1 Operazioni Primitive 

### Creazione di un Processo

Parametri:

- tipo (di sistema o di utente)
- priorità
- programma da mandare in esecuzione (da cui ricavare dimensioni e quantità di memoria per DATI e CODICE)
- informazioni di protezione

Effetto:

- creazione di un nuovo descrittore (o suo recupero dal POOL di descrittori liberi), sua inizializzazione con anche allocazione della memoria che rappresenta lo spazio di indirizzamento del processo, infine transizione dello stato (**STATO = PRONTO**)
- inserimento nella coda dei processi pronti, o eventualmente nella coda di priorità se c'è gestione della priorità

#### Creazione in UNIX

In UNIX si utilizza la ***primitiva FORK***. In questo caso tutti i parametri che servono al Kernel per effettuare la creazione sono *impliciti*. Il tipo del processo, così come la priorità, dipende dal tipo che siamo nel momento in cui effettuiamo la creazione. Unix usa lo stato *IDLE* (esplicito) fino a che la fase di inizializzazione non è terminata e poi lo stato *READY*.

### Distruzione di un Processo

Questa operazione viene usata per:
* terminazione o autodistruzione
* uccisione (un processo può volerne distruggere un altro)

Parametri:

- identificatore processo

Effetto:

- recupero risorse assegnate
- eliminazione dal sistema (se è in una coda, viene estratto)
- distruzione del suo descrittore (o reinserimento nel POOL di descrittori liberi)

#### Distruzione in UNIX

In UNIX si utilizza la ***primitiva EXIT*** (per terminazione o autodistruzione) e ***primitiva KILL*** con *SIGKILL* (uccisione di un processo da parte di un altro processo). Unix usa lo stato *TERMINATED* e se necessario lo stato *ZOMBIE* per indicare uno stato padre in attesa della terminazione del processo figlio, in questo modo viene mantenuto il descrittore del processo figlio che può essere utile al processo padre.

### Sospensione di un Processo

Usata da:
* richieste di I/O
* In *Ambiente Globale* &rarr; *WAIT* sospensiva su semaforo
* In *Ambiente Locale* &rarr; *RECEIVE* se manca messaggio, *SEND SINCRONA* se manca il rendez-vous e *SEND ASINCRONA* con canale pieno se bufferizzazione limitata

Parametri:

- identificatore processo

Effetto:

- spostamento del suo descrittore dalla coda dei processi pronti, (se come per ipotesi precedente è questa presenta il processo in esecuzione) alla coda di sospensione e transizione dello stato in (***STATO = SOSPESO***).
- selezione del prossimo processo pronto come processo *RUNNING* (secondo l'algoritmo di SCHEDULING) &rarr; PROCESS
SWITCHING (o cambio di contesto)

### Riattivazione di un Processo

Usata da:
* completamento di richieste  I/O &rarr; gestione interrupt
* In *Ambiente Globale* &rarr; *SIGNAL* su semaforo con coda
* In *Ambiente Locale* &rarr; *RECEIVE* quando arriva il messaggio, *SEND SINCRONA* quando arriva il receiver e *SEND ASINCRONA* quando si libera spazio nel canale limitato

Parametri:

- identificatore processo

Effetto:

- spostamento del suo descrittore dalla coda di sospensione alla coda dei processi pronti. La riattivazione di un processo *non implica mai che esso passi direttamente in stato di esecuzione*. Transizione dello stato in (***STATO = PRONTO***).
- ***eventuale*** selezione del prossimo processo pronto come processo *RUNNING* (algoritmo di SCHEDULING) &rarr; PROCESS SWITCHING. L'arrivo di un processo nella coda dei processi pronti può far sì che quel processo debba immediatamente andare in esecuzione. Se è già presente un processo in fase di *running* questo deve ritornare nello stato *pronto*.

### Sospensione Temporizzata di un Processo

Usata per:
* autosospensione (ad esempio per uso di time-out)
* sospensione di un altro processo &rarr; collegata alla gestione di un ***TIMER***

Parametri:

- identificatore processo
- durata

Effetto:

- spostamento del suo descrittore [dalla coda dei processi pronti, (se come per ipotesi precedente questa presenta il processo in esecuzione) alla ***coda del TIMER*** e transizione dello stato (***STATO = SOSPESO***)
- selezione del prossimo processo pronto come processo RUNNING (algoritmo di SCHEDULING) &rarr; PROCESS SWITCHING

#### Sospensione Temporizzata in UNIX

In UNIX, si utilizza la ***primitiva SLEEP*** per l'autosospensione, mentre *non è prevista una primitiva che permetta di sospendere un altro processo*. Allo scadere del tempo di sospensione &rarr; riattivazione (con la stessa primitiva indicata precedentemente). La riattivazione infatti è *indipendente da qualsiasi sia stata la causa di sospensione*.

### Lettura degli Attributi di un Processo

Visto che i *descrittori di un processo* fanno parte dello spazio di indirizzamento accessibile solo al nucleo, se si vogliono rendere disponibili delle informazioni ai programmatori di sistema è necessario prevedere delle *primitive che vadano a leggere alcune informazioni presenti nei descrittori dei processi*.

#### Lettura degli Attributi in UNIX	

Queste primitive in UNIX sono costituite dalle operazioni: GETPID, GETPPID, GETUID, GETGID, GETEUID, GETEGID.

### Modifica degli Attributi di un Processo

Un esempio di attributo di un processo che può essere soggetto a modifica nel corso della sua vita è la *priorità*.

#### Modifica degli Attributi in UNIX

In UNIX esiste una primitiva chiamata *NICE* che permette di modificare la priorità di un processo (a livello utente), *abbassandola*.

I progettisti devono considerare che le *chiamate di sistema possano fallire* e quindi devono prevedere **CODICI DI ERRORE**.

## 3.4.2 Transizioni di Stato

<img src="res/03_1_transizione_di_stato.PNG" alt="transizione-di-stato" style="zoom:67%;" />

0. **da programma a processo**
1. **da esecuzione a sospeso**
2. **da sospeso a pronto**
3. **da pronto a esecuzione** &rarr; effetto di una azione dello SCHEDULER
4. **da esecuzione a pronto** &rarr; effetto di una azione dello SCHEDULER dovuta a uso di PREEMPTION
5. **da esecuzione a terminazione**

<img src="res/03_2_transizione_di_stato_UNIX.PNG" alt="transizioni-di-stato-UNIX" style="zoom: 67%;" />

- *SWAPPED* immagine copiata su disco
  *SWAP OUT* &rarr; si applica preferibilmente a processi sospesi
- *ZOMBIE* terminato, ma presente in attesa di consegna del risultato al padre (che non ha ancora aspettato il figlio)

## 3.4.3 Cambio di Processo

Il *cambio di processo* (detto anche *cambio di contesto*, ***context switching***) è necessario quando si *effettua la commutazione della CPU dal processo running al prossimo processo che deve andare in esecuzione* (in base all’algoritmo di scheduling).

**N.B**: Si ha a causa delle transizioni *(1)* e *(4)* e ha come effetto finale la transizione *(3)*

Quando il nucleo deve effettuare il cambio di processo sono necessarie le seguenti azioni:

- *salvataggio del contesto del processo in esecuzione*, dai registri macchina, *nel suo descrittore*
- *inserimento del suo descrittore nella coda appropriata* (di processi sospesi o dei processi pronti)
- *caricamento dell’identificatore del nuovo processo che deve andare in esecuzione* nel registro RUNNING
- *ripristino del contesto del nuovo processo running* nei registri macchina

## 3.4.4 Dispatcher

Il DISPATCHER è quel modulo del nucleo che passa effettivamente il controllo della CPU ai processi scelti dallo scheduler (con il quale non deve essere confuso). Quindi si occupa di effettuare:

- il *cambio di contesto* (con le azioni sopra descritte)
- il *passaggio da modo SUPERVISORE a modo UTENTE*
- il *salto alla giusta posizione del programma utente* per riattivarne l'esecuzione

## 3.4.5 Creazione di un Processo

Quando un processo crea un nuovo processo, ci sono ***due possibilità*** per quanto riguarda lo ***spazio di indirizzamento*** del nuovo processo:

- il *processo figlio è un duplicato del processo genitore*
- *nel processo figlio si carica un diverso programma*, da specificare a lato della creazione

### Esempi nei Sistemi Operativi

#### UNIX

In UNIX, un nuovo processo si crea per mezzo della ***primitiva FORK***. Il nuovo processo è composto da una copia dello
spazio di indirizzamento del processo padre per quanto riguarda i dati (sia utente che kernel, il codice viene condiviso e i due processi eseguono lo *stesso programma*). Molto spesso dopo la creazione, uno dei due processi (il padre o, più normalmente, il figlio) impiega una delle primitive della famiglia ***EXEC*** per sostituire lo spazio di memoria del processo con un nuovo programma.

#### VMS

La creazione di un processo carica il programma specificato in tale processo e ne avvia l'esecuzione.

#### Windows

Sono previste entrambe le possibilità: la *semantica simile alla FORK*, e *la semantica simile a VMS*.

## 3.4.6 Tabelle per Processi in UNIX

<img src="res/03_3_tabelle_processi_UNIX.PNG" alt="tabelle-processi-UNIX" style="zoom: 80%;" />



### Tabelle del KERNEL - Parte Residente

#### Process Table

La Process Table rappresenta la *pool di descrittori* sia *liberi* che *in uso* per i processi attivi nel sistema, specificato da un campo apposito. Presenta dunque un ***descrittore di processo*** per ***ogni processo attivo nel sistema***.

#### Text Table

In questa tabella è presente *un elemento per ogni codice attivo*, presentando un'ulteriore tabella per rappresentare in modo facile la condivisione di codice tra processo padre e i vari processi figli (anche solo uno).

Queste due tabelle appartengono al *kernel* e si trovano nella parte della *Parte Residente*, sempre accessibile a prescindere dalla gestione della memoria fatta sui processi utente

### Spazio di Indirizzamento dei Processi

Si trova nella *Parte Swappabile*. Se il processo *non è in stato swapped* allora in memoria centrale, nello spazio utente avremo la presenza di *aree dedicate ad ogni singolo processo*:

#### Area di KERNEL

In genere accessibile *solo durante la esecuzione delle primitive* del Sistema Operativo, nella quale troviamo:

- Stack &rarr; utilizzato per le *system calls*
- System Data &rarr; a sua volta suddivisa in:
  - *enviroment*, dove oltre all'ambiente di esecuzione ci sono anche *argc* e *argv* (parametri passati all'invocazione del *main*)
  - *user area* (o *user data*) dove troviamo la *tabella dei file aperti* e la *tabelle di trattamento dei segnali*

#### Area DATI

Suddivisa in:

- Dati Globali &rarr; che nel linguaggio C sono le *variabili static ed extern*
- Dati Dinamici &rarr; dati gestiti a *Stack*, come variabili definite a livello di singole istruzioni nella funzione main e dati gestiti a *Heap*, come le zone di memoria che si vanno ad allocare con primitive tipo *mallock()*

#### Area di CODICE 

Ne è solo una ma più processi possono fare riferimento alla *stessa* tramite il loro descrittore di processo.

## 3.4.7 Primitive in UNIX/LINUX

### Creazione di un Processo

#### FORK - UNIX

Se si verifica un qualsiasi errore, la fork restituisce al processo parent il valore -1. 

Se la fork ha successo viene creato un processo figlio:

- inserisce una nuova entry utilizzando uno degli elementi pre-allocati nella **tabella dei processi** &rarr; descrittore per il nuovo processo con attributi ereditati dal padre: ad esempio stesso *UID* e *GID*
- l'area dati utente del processo figlio viene copiata dall'area dati utente del processo padre
- il nuovo processo esegue lo stesso codice del padre &rarr; aggiornamento contatore nell'elemento della text table, perché padre e figlio condividono lo stesso codice
- l'area kernel del processo figlio viene duplicata dall'area kernel area del processo padre &rarr; tabella dei file aperti e situazione nello stato dei segnali uguale a quella del processo padre 
- inserisce il descrittore del figlio nella coda dei processi pronti

Durante le *prime 4 fasi* il processo è in *stato IDLE*.

#### FORK - LINUX (versione 2.0)

L'unica differenza a livello implementativo dalla precedente è che *non viene fatta una copia iniziale dell'area utente*. Questo rappresenta un'***ottimizzazione***. Nell'area del padre viene messa un *flag*:

- area dati marcata *write-protected*
- una scrittura genera un *page-fault* (eccezione per tentativo di accesso)
- il *kernel fa una copia dell'area dati* e dà al processo che deve scrivere il permesso di modificarla

L'ottimizzazione di non fare immediatamente la copia dati è dovuta al fatto che spesso un figlio, appena dopo essere stato creato, va a fare una *EXEC* per poter eseguire un nuovo programma, andando così a creare *una nuova area dati*.

### Esecuzione di un Programma

#### EXEC

UNIX consente di cambiare il programma che un processo sta eseguendo usando una delle primitive della famiglia *EXEC*.
**N.B.1**: è questa primitiva che, eventualmente, cambia *EUID* e/o *EGID*.
**N.B.2**: come effetto collaterale (non visibile nella figura), viene cambiata la tabella che specifica come vengono trattati i segnali. I segnali che precedentemente erano ignorati rimangono tali così come quelli collegati alle azioni di default. Tutti i segnali che prevedevano un'azione di trattamento di quel segnale vengono tutti riportati all'azione di default: le azioni specifiche appartengono al codice, pertanto è bene svincolarle dal codice precedente. 

<img src="res/03_4_prima_dopo_exec.PNG" alt="prima-dopo-EXEC" style="zoom:80%;" />

Si consideri la generazione di un certo processo. Supponiamo che il figlio abbia ottenuto come copia dal padre una *Kernel area*, un'*area Dati* costituita da *Stack e Heap* e ha ottenuto per condivisione il *codice del padre*. Se il figlio effettua una *EXEC*, l'area dati viene *deallocata* e ne viene allocata una nuova che serve per eseguire il nuovo programma da mandare in esecuzione. Poiché il il codice che si esegue è diverso, deve essere caricato o recuperato (se era già in uso) l'elemento della *Text table* opportuno. In questo modo il figlio non punta più all'elemento della Text table a cui puntava il padre, ma punterà al codice nuovo.

